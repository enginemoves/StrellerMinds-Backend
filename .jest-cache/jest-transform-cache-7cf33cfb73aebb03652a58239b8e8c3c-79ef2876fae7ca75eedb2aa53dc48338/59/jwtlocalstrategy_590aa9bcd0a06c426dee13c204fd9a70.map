{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\auth\\strategies\\jwt-local.strategy.ts","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,2CAMwB;AACxB,qCAAyC;AACzC,iDAAmC;AAEnC,+BAAoC;AACpC,6CAAmD;AACnD,qCAA+C;AAC/C,2CAA+C;AAG/C,6DAAyD;AACzD,gFAA2E;AAC3E,qEAA0D;AAC1D,2EAAgE;AAChE,oEAAgE;AAIzD,IAAM,gBAAgB,GAAtB,MAAM,gBAAgB;IAC3B,YACmB,YAA0B,EAC1B,UAAsB,EACtB,YAA0B,EAC1B,yBAAoD,EAEpD,mBAA0C,EAE1C,sBAAgD,EAChD,aAA4B;QAR5B,iBAAY,GAAZ,YAAY,CAAc;QAC1B,eAAU,GAAV,UAAU,CAAY;QACtB,iBAAY,GAAZ,YAAY,CAAc;QAC1B,8BAAyB,GAAzB,yBAAyB,CAA2B;QAEpD,wBAAmB,GAAnB,mBAAmB,CAAuB;QAE1C,2BAAsB,GAAtB,sBAAsB,CAA0B;QAChD,kBAAa,GAAb,aAAa,CAAe;IAC5C,CAAC;IAEJ,QAAQ,CAAC,WAAgB;QACvB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC7C,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,KAAa,EAAE,QAAgB;QAChD,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACxD,IAAI,CAAC,IAAI;YAAE,MAAM,IAAI,8BAAqB,CAAC,qBAAqB,CAAC,CAAC;QAElE,MAAM,eAAe,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtE,IAAI,CAAC,eAAe;YAAE,MAAM,IAAI,8BAAqB,CAAC,qBAAqB,CAAC,CAAC;QAE7E,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1B,MAAM,IAAI,8BAAqB,CAAC,gCAAgC,CAAC,CAAC;QACpE,CAAC;QAED,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC;gBAChC,EAAE,EAAE,IAAI,CAAC,KAAK;gBACd,OAAO,EAAE,yBAAyB;gBAClC,YAAY,EAAE,SAAS;gBACvB,OAAO,EAAE;oBACP,IAAI,EAAE,IAAI,CAAC,SAAS;oBACpB,IAAI,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;iBAC/B;aACF,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,8BAA8B,EAAE,KAAK,CAAC,CAAC;QACvD,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,QAAgB;QACrC,MAAM,gBAAgB,GAAG,IAAI,CAAC,yBAAyB,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACnF,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC;YAC9B,MAAM,IAAI,4BAAmB,CAAC;gBAC5B,OAAO,EAAE,qCAAqC;gBAC9C,MAAM,EAAE,gBAAgB,CAAC,MAAM;aAChC,CAAC,CAAC;QACL,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,WAAgB;QAC7B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,QAAQ,EAAE,GAAG,WAAW,CAAC;QACrD,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAEtC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAChE,IAAI,YAAY;YAAE,MAAM,IAAI,4BAAmB,CAAC,qBAAqB,CAAC,CAAC;QAEvE,MAAM,cAAc,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QAEvD,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC;YAC1C,KAAK;YACL,QAAQ,EAAE,cAAc;YACxB,GAAG,QAAQ;SACZ,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,IAAS;QAC5B,MAAM,OAAO,GAAG;YACd,GAAG,EAAE,IAAI,CAAC,EAAE;YACZ,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,KAAK,EAAE,IAAI,CAAC,IAAI;SACjB,CAAC;QAEF,MAAM,CAAC,WAAW,EAAE,YAAY,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YACpD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,OAAO,EAAE;gBACjC,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,YAAY,CAAC;gBACpD,SAAS,EAAE,IAAI;aAChB,CAAC;YACF,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,OAAO,EAAE;gBACjC,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,sBAAsB,CAAC;gBAC9D,SAAS,EAAE,IAAI;aAChB,CAAC;SACH,CAAC,CAAC;QAEH,MAAM,kBAAkB,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAC/D,MAAM,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE,EAAE,kBAAkB,CAAC,CAAC;QAExE,OAAO;YACL,WAAW;YACX,YAAY;YACZ,SAAS,EAAE,IAAI;SAChB,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,IAAS;QACnB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC/C,OAAO;YACL,YAAY,EAAE,MAAM,CAAC,WAAW;YAChC,aAAa,EAAE,MAAM,CAAC,YAAY;YAClC,UAAU,EAAE,MAAM,CAAC,SAAS;YAC5B,IAAI,EAAE;gBACJ,EAAE,EAAE,IAAI,CAAC,EAAE;gBACX,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,KAAK,EAAE,IAAI,CAAC,KAAK;aAClB;SACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,MAAc,EAAE,YAAoB;QACrD,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,YAAY,EAAE;gBACzC,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,sBAAsB,CAAC;aAC/D,CAAC,CAAC;YAEH,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC;gBAC5D,KAAK,EAAE;oBACL,MAAM;oBACN,SAAS,EAAE,KAAK;oBAChB,SAAS,EAAE,IAAA,kBAAQ,EAAC,IAAI,IAAI,EAAE,CAAC;iBAChC;aACF,CAAC,CAAC;YAEH,IAAI,CAAC,WAAW;gBAAE,MAAM,IAAI,8BAAqB,CAAC,kCAAkC,CAAC,CAAC;YAEtF,MAAM,YAAY,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,YAAY,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;YAC3E,IAAI,CAAC,YAAY;gBAAE,MAAM,IAAI,8BAAqB,CAAC,uBAAuB,CAAC,CAAC;YAE5E,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;YAE9E,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACrD,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,8BAAqB,CAAC,uBAAuB,CAAC,CAAC;QAC3D,CAAC;IACH,CAAC;IAED,KAAK,CAAC,uBAAuB,CAAC,MAAc;QAC1C,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CACtC,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,EAC5B,EAAE,SAAS,EAAE,IAAI,EAAE,CACpB,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,qCAA4B,CAAC,+BAA+B,CAAC,CAAC;QAC1E,CAAC;IACH,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,MAAc;QACzB,MAAM,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QACzD,OAAO,EAAE,OAAO,EAAE,yBAAyB,EAAE,CAAC;IAChD,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,KAAa;QAC/B,IAAI,CAAC;YACH,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,EAAE;gBACvD,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,YAAY,CAAC;aACrD,CAAC,CAAC;YACH,OAAO,OAAO,CAAC;QACjB,CAAC;QAAC,MAAM,CAAC;YACP,MAAM,IAAI,8BAAqB,CAAC,eAAe,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,KAAa;QAChC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACpD,IAAI,CAAC,IAAI;YAAE,MAAM,IAAI,0BAAiB,CAAC,sCAAsC,CAAC,CAAC;QAE/E,MAAM,KAAK,GAAG,IAAA,SAAM,GAAE,CAAC;QACvB,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC;QAE7C,MAAM,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC;YACjD,IAAI;YACJ,KAAK;YACL,SAAS;YACT,OAAO,EAAE,gBAAgB;YACzB,SAAS,EAAE,KAAK;SACjB,CAAC,CAAC;QAEH,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAEhD,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC;YAChC,EAAE,EAAE,IAAI,CAAC,KAAK;YACd,OAAO,EAAE,wBAAwB;YACjC,YAAY,EAAE,gBAAgB;YAC9B,OAAO,EAAE;gBACP,IAAI,EAAE,IAAI,CAAC,SAAS;gBACpB,KAAK;aACN;SACF,CAAC,CAAC;QAEH,OAAO,EAAE,OAAO,EAAE,2BAA2B,EAAE,CAAC;IAClD,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,KAAa;QACpC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC;YACvD,KAAK,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,gBAAgB,EAAE,SAAS,EAAE,KAAK,EAAE;YAC7D,SAAS,EAAE,CAAC,MAAM,CAAC;SACpB,CAAC,CAAC;QAEH,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,EAAE,CAAC;YACnD,MAAM,IAAI,4BAAmB,CAAC,0CAA0C,CAAC,CAAC;QAC5E,CAAC;QAED,OAAO,SAAS,CAAC,IAAI,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,KAAa,EAAE,WAAmB;QACpD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC;YACvD,KAAK,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,gBAAgB,EAAE,SAAS,EAAE,KAAK,EAAE;YAC7D,SAAS,EAAE,CAAC,MAAM,CAAC;SACpB,CAAC,CAAC;QAEH,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,EAAE,CAAC;YACnD,MAAM,IAAI,4BAAmB,CAAC,0CAA0C,CAAC,CAAC;QAC5E,CAAC;QAED,MAAM,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;QAC5B,MAAM,cAAc,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;QAE1D,SAAS,CAAC,SAAS,GAAG,IAAI,CAAC;QAC3B,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAE/C,OAAO,EAAE,OAAO,EAAE,6BAA6B,EAAE,CAAC;IACpD,CAAC;IAGD,KAAK,CAAC,oBAAoB,CAAC,KAAa;QACtC,mFAAmF;QACnF,+CAA+C;QAC/C,OAAO,EAAE,OAAO,EAAE,+BAA+B,KAAK,EAAE,EAAE,CAAC;IAC7D,CAAC;IACD,KAAK,CAAC,cAAc,CAAC,MAAc,EAAE,eAAuB,EAAE,WAAmB;QAC/E,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACrD,IAAI,CAAC,IAAI;YAAE,MAAM,IAAI,8BAAqB,CAAC,gBAAgB,CAAC,CAAC;QAE7D,MAAM,sBAAsB,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpF,IAAI,CAAC,sBAAsB;YAAE,MAAM,IAAI,4BAAmB,CAAC,+BAA+B,CAAC,CAAC;QAE5F,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;QAEzC,MAAM,cAAc,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;QAE1D,MAAM,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;QAE3C,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAA;AA9PY,4CAAgB;2BAAhB,gBAAgB;IAD5B,IAAA,mBAAU,GAAE;IAOR,WAAA,IAAA,0BAAgB,EAAC,6BAAS,CAAC,CAAA;IAE3B,WAAA,IAAA,0BAAgB,EAAC,mCAAY,CAAC,CAAA;yDANA,4BAAY,oBAAZ,4BAAY,oDACd,gBAAU,oBAAV,gBAAU,oDACR,4BAAY,oBAAZ,4BAAY,oDACC,uDAAyB,oBAAzB,uDAAyB,oDAE/B,oBAAU,oBAAV,oBAAU,oDAEP,oBAAU,oBAAV,oBAAU,oDACnB,sBAAa,oBAAb,sBAAa;GAVpC,gBAAgB,CA8P5B;AACD,SAAS,UAAU,CAAC,IAAU,EAAE,OAAe;IAC7C,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,OAAO,GAAG,KAAK,CAAC,CAAC;AACpD,CAAC","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\auth\\strategies\\jwt-local.strategy.ts"],"sourcesContent":["import {\r\n  BadRequestException,\r\n  Injectable,\r\n  UnauthorizedException,\r\n  NotFoundException,\r\n  InternalServerErrorException,\r\n} from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport * as bcrypt from 'bcryptjs';\r\nimport * as crypto from 'crypto';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository, MoreThan } from 'typeorm';\r\nimport { ConfigService } from '@nestjs/config';\r\n\r\nimport { AuthResponseDto } from '../dto/auth-response.dto';\r\nimport { EmailService } from '../../email/email.service';\r\nimport { PasswordValidationService } from '../password-validation.service';\r\nimport { AuthToken } from '../entities/auth-token.entity';\r\nimport { RefreshToken } from '../entities/refresh-token.entity';\r\nimport { UsersService } from 'src/users/services/users.service';\r\nimport { IAuthStrategy } from './auth-strategy.interface';\r\n\r\n@Injectable()\r\nexport class JwtLocalStrategy implements IAuthStrategy {\r\n  constructor(\r\n    private readonly usersService: UsersService,\r\n    private readonly jwtService: JwtService,\r\n    private readonly emailService: EmailService,\r\n    private readonly passwordValidationService: PasswordValidationService,\r\n    @InjectRepository(AuthToken)\r\n    private readonly authTokenRepository: Repository<AuthToken>,\r\n    @InjectRepository(RefreshToken)\r\n    private readonly refreshTokenRepository: Repository<RefreshToken>,\r\n    private readonly configService: ConfigService,\r\n  ) {}\r\n  name: string;\r\n  validate(credentials: any): Promise<any> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  async validateUser(email: string, password: string): Promise<any> {\r\n    const user = await this.usersService.findByEmail(email);\r\n    if (!user) throw new UnauthorizedException('Invalid credentials');\r\n\r\n    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n    if (!isPasswordValid) throw new UnauthorizedException('Invalid credentials');\r\n\r\n    if (!user.isEmailVerified) {\r\n      throw new UnauthorizedException('Please verify your email first');\r\n    }\r\n\r\n    try {\r\n      await this.emailService.sendEmail({\r\n        to: user.email,\r\n        subject: 'Welcome to Our Platform',\r\n        templateName: 'welcome',\r\n        context: {\r\n          name: user.firstName,\r\n          year: new Date().getFullYear(),\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.error('Error sending welcome email:', error);\r\n    }\r\n\r\n    return user;\r\n  }\r\n\r\n  async validatePassword(password: string): Promise<boolean> {\r\n    const validationResult = this.passwordValidationService.validatePassword(password);\r\n    if (!validationResult.isValid) {\r\n      throw new BadRequestException({\r\n        message: 'Password does not meet requirements',\r\n        errors: validationResult.errors,\r\n      });\r\n    }\r\n    return true;\r\n  }\r\n\r\n  async register(credentials: any): Promise<AuthResponseDto> {\r\n    const { email, password, ...userData } = credentials;\r\n    await this.validatePassword(password);\r\n\r\n    const existingUser = await this.usersService.findByEmail(email);\r\n    if (existingUser) throw new BadRequestException('User already exists');\r\n\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    const user = await this.usersService.create({\r\n      email,\r\n      password: hashedPassword,\r\n      ...userData,\r\n    });\r\n\r\n    return this.login(user);\r\n  }\r\n\r\n  async generateTokens(user: any) {\r\n    const payload = {\r\n      sub: user.id,\r\n      email: user.email,\r\n      roles: user.role,\r\n    };\r\n\r\n    const [accessToken, refreshToken] = await Promise.all([\r\n      this.jwtService.signAsync(payload, {\r\n        secret: this.configService.get<string>('JWT_SECRET'),\r\n        expiresIn: '1h',\r\n      }),\r\n      this.jwtService.signAsync(payload, {\r\n        secret: this.configService.get<string>('REFRESH_TOKEN_SECRET'),\r\n        expiresIn: '7d',\r\n      }),\r\n    ]);\r\n\r\n    const hashedRefreshToken = await bcrypt.hash(refreshToken, 10);\r\n    await this.usersService.updateRefreshToken(user.id, hashedRefreshToken);\r\n\r\n    return {\r\n      accessToken,\r\n      refreshToken,\r\n      expiresIn: 3600,\r\n    };\r\n  }\r\n\r\n  async login(user: any): Promise<AuthResponseDto> {\r\n    const tokens = await this.generateTokens(user);\r\n    return {\r\n      access_token: tokens.accessToken,\r\n      refresh_token: tokens.refreshToken,\r\n      expires_in: tokens.expiresIn,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        roles: user.roles,\r\n      },\r\n    };\r\n  }\r\n\r\n  async refreshToken(userId: string, refreshToken: string) {\r\n    try {\r\n      await this.jwtService.verify(refreshToken, {\r\n        secret: this.configService.get<string>('REFRESH_TOKEN_SECRET'),\r\n      });\r\n\r\n      const tokenEntity = await this.refreshTokenRepository.findOne({\r\n        where: {\r\n          userId,\r\n          isRevoked: false,\r\n          expiresAt: MoreThan(new Date()),\r\n        },\r\n      });\r\n\r\n      if (!tokenEntity) throw new UnauthorizedException('Invalid or expired refresh token');\r\n\r\n      const isTokenValid = await bcrypt.compare(refreshToken, tokenEntity.token);\r\n      if (!isTokenValid) throw new UnauthorizedException('Invalid refresh token');\r\n\r\n      await this.refreshTokenRepository.update(tokenEntity.id, { isRevoked: true });\r\n\r\n      const user = await this.usersService.findOne(userId);\r\n      return this.generateTokens(user);\r\n    } catch (error) {\r\n      throw new UnauthorizedException('Invalid refresh token');\r\n    }\r\n  }\r\n\r\n  async revokeUserRefreshTokens(userId: string): Promise<void> {\r\n    try {\r\n      await this.refreshTokenRepository.update(\r\n        { userId, isRevoked: false },\r\n        { isRevoked: true },\r\n      );\r\n    } catch (error) {\r\n      throw new InternalServerErrorException('Error revoking refresh tokens');\r\n    }\r\n  }\r\n\r\n  async logout(userId: string) {\r\n    await this.usersService.updateRefreshToken(userId, null);\r\n    return { message: 'Logged out successfully' };\r\n  }\r\n\r\n  async validateToken(token: string) {\r\n    try {\r\n      const payload = await this.jwtService.verifyAsync(token, {\r\n        secret: this.configService.get<string>('JWT_SECRET'),\r\n      });\r\n      return payload;\r\n    } catch {\r\n      throw new UnauthorizedException('Invalid token');\r\n    }\r\n  }\r\n\r\n  async forgotPassword(email: string) {\r\n    const user = await this.usersService.findOne(email);\r\n    if (!user) throw new NotFoundException('User with this email does not exist.');\r\n\r\n    const token = uuidv4();\r\n    const expiresAt = addMinutes(new Date(), 15);\r\n\r\n    const resetToken = this.authTokenRepository.create({\r\n      user,\r\n      token,\r\n      expiresAt,\r\n      purpose: 'reset_password',\r\n      isRevoked: false,\r\n    });\r\n\r\n    await this.authTokenRepository.save(resetToken);\r\n\r\n    await this.emailService.sendEmail({\r\n      to: user.email,\r\n      subject: 'Password Reset Request',\r\n      templateName: 'reset-password',\r\n      context: {\r\n        name: user.firstName,\r\n        token,\r\n      },\r\n    });\r\n\r\n    return { message: 'Password reset email sent' };\r\n  }\r\n\r\n  async validateResetToken(token: string) {\r\n    const authToken = await this.authTokenRepository.findOne({\r\n      where: { token, purpose: 'reset_password', isRevoked: false },\r\n      relations: ['user'],\r\n    });\r\n\r\n    if (!authToken || authToken.expiresAt < new Date()) {\r\n      throw new BadRequestException('Invalid or expired password reset token.');\r\n    }\r\n\r\n    return authToken.user;\r\n  }\r\n\r\n  async resetPassword(token: string, newPassword: string) {\r\n    const authToken = await this.authTokenRepository.findOne({\r\n      where: { token, purpose: 'reset_password', isRevoked: false },\r\n      relations: ['user'],\r\n    });\r\n\r\n    if (!authToken || authToken.expiresAt < new Date()) {\r\n      throw new BadRequestException('Invalid or expired password reset token.');\r\n    }\r\n\r\n    const user = authToken.user;\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n    authToken.isRevoked = true;\r\n    await this.authTokenRepository.save(authToken);\r\n\r\n    return { message: 'Password successfully reset' };\r\n  }\r\n\r\n\r\n  async requestPasswordReset(email: string): Promise<any> {\r\n    // Implement your password reset logic here, e.g., generate token, send email, etc.\r\n    // For now, just return a placeholder response.\r\n    return { message: `Password reset link sent to ${email}` };\r\n  }\r\n  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<boolean> {\r\n    const user = await this.usersService.findOne(userId);\r\n    if (!user) throw new UnauthorizedException('User not found');\r\n\r\n    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);\r\n    if (!isCurrentPasswordValid) throw new BadRequestException('Current password is incorrect');\r\n\r\n    await this.validatePassword(newPassword);\r\n\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n    await this.revokeUserRefreshTokens(userId);\r\n\r\n    return true;\r\n  }\r\n}\r\nfunction addMinutes(date: Date, minutes: number): Date {\r\n  return new Date(date.getTime() + minutes * 60000);\r\n}\r\n\r\n"],"version":3}