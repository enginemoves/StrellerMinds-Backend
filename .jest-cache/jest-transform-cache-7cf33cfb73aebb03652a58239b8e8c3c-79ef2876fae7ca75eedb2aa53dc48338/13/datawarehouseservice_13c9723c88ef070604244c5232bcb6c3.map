{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\analytic\\services\\data-warehouse.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\analytic\\services\\data-warehouse.service.ts"],"sourcesContent":["import { Injectable, Logger } from \"@nestjs/common\"\r\nimport type { Repository } from \"typeorm\"\r\n\r\nimport { type DataWarehouseMetric, MetricType, AggregationType } from \"../entities/data-warehouse-metric.entity\"\r\n\r\nexport interface MetricData {\r\n  metricName: string\r\n  metricType: MetricType\r\n  value: number\r\n  dimensions: Record<string, string>\r\n  tags?: Record<string, string>\r\n  timestamp: Date\r\n  aggregationType?: AggregationType\r\n  granularity?: string\r\n}\r\n\r\n@Injectable()\r\nexport class DataWarehouseService {\r\n  private readonly logger = new Logger(DataWarehouseService.name)\r\n\r\n  constructor(private readonly metricRepository: Repository<DataWarehouseMetric>) {}\r\n\r\n  async recordMetric(metricData: MetricData): Promise<void> {\r\n    try {\r\n      const metric = this.metricRepository.create({\r\n        ...metricData,\r\n        aggregationType: metricData.aggregationType || AggregationType.SUM,\r\n        granularity: metricData.granularity || \"1h\",\r\n      })\r\n\r\n      await this.metricRepository.save(metric)\r\n    } catch (error) {\r\n      this.logger.error(`Failed to record metric: ${error.message}`, error.stack)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  async getMetrics(filters: {\r\n    metricName?: string\r\n    metricType?: MetricType\r\n    dimensions?: Record<string, string>\r\n    startDate?: Date\r\n    endDate?: Date\r\n    granularity?: string\r\n    limit?: number\r\n  }): Promise<DataWarehouseMetric[]> {\r\n    const query = this.metricRepository.createQueryBuilder(\"metric\")\r\n\r\n    if (filters.metricName) {\r\n      query.andWhere(\"metric.metricName = :metricName\", {\r\n        metricName: filters.metricName,\r\n      })\r\n    }\r\n\r\n    if (filters.metricType) {\r\n      query.andWhere(\"metric.metricType = :metricType\", {\r\n        metricType: filters.metricType,\r\n      })\r\n    }\r\n\r\n    if (filters.dimensions) {\r\n      for (const [key, value] of Object.entries(filters.dimensions)) {\r\n        query.andWhere(`metric.dimensions ->> :key = :value`, {\r\n          key,\r\n          value,\r\n        })\r\n      }\r\n    }\r\n\r\n    if (filters.startDate) {\r\n      query.andWhere(\"metric.timestamp >= :startDate\", {\r\n        startDate: filters.startDate,\r\n      })\r\n    }\r\n\r\n    if (filters.endDate) {\r\n      query.andWhere(\"metric.timestamp <= :endDate\", {\r\n        endDate: filters.endDate,\r\n      })\r\n    }\r\n\r\n    if (filters.granularity) {\r\n      query.andWhere(\"metric.granularity = :granularity\", {\r\n        granularity: filters.granularity,\r\n      })\r\n    }\r\n\r\n    query.orderBy(\"metric.timestamp\", \"DESC\")\r\n\r\n    if (filters.limit) {\r\n      query.limit(filters.limit)\r\n    }\r\n\r\n    return query.getMany()\r\n  }\r\n\r\n  async aggregateMetrics(startTime: Date, endTime: Date, granularity: string): Promise<void> {\r\n    this.logger.log(\r\n      `Aggregating metrics from ${startTime.toISOString()} to ${endTime.toISOString()} with granularity ${granularity}`,\r\n    )\r\n\r\n    // Get unique metric names and dimensions combinations\r\n    const uniqueMetrics = await this.metricRepository\r\n      .createQueryBuilder(\"metric\")\r\n      .select([\"metric.metricName\", \"metric.dimensions\", \"metric.aggregationType\"])\r\n      .where(\"metric.timestamp >= :startTime\", { startTime })\r\n      .andWhere(\"metric.timestamp < :endTime\", { endTime })\r\n      .andWhere(\"metric.granularity != :granularity\", { granularity })\r\n      .groupBy(\"metric.metricName, metric.dimensions, metric.aggregationType\")\r\n      .getRawMany()\r\n\r\n    for (const uniqueMetric of uniqueMetrics) {\r\n      await this.aggregateMetricGroup(\r\n        uniqueMetric.metric_metricName,\r\n        JSON.parse(uniqueMetric.metric_dimensions),\r\n        uniqueMetric.metric_aggregationType,\r\n        startTime,\r\n        endTime,\r\n        granularity,\r\n      )\r\n    }\r\n  }\r\n\r\n  private async aggregateMetricGroup(\r\n    metricName: string,\r\n    dimensions: Record<string, string>,\r\n    aggregationType: AggregationType,\r\n    startTime: Date,\r\n    endTime: Date,\r\n    granularity: string,\r\n  ): Promise<void> {\r\n    const query = this.metricRepository\r\n      .createQueryBuilder(\"metric\")\r\n      .where(\"metric.metricName = :metricName\", { metricName })\r\n      .andWhere(\"metric.timestamp >= :startTime\", { startTime })\r\n      .andWhere(\"metric.timestamp < :endTime\", { endTime })\r\n      .andWhere(\"metric.granularity != :granularity\", { granularity })\r\n\r\n    // Add dimensions filter\r\n    for (const [key, value] of Object.entries(dimensions)) {\r\n      query.andWhere(`metric.dimensions ->> :key = :value`, {\r\n        key: `dim_${key}`,\r\n        value,\r\n      })\r\n    }\r\n\r\n    let aggregatedValue: number\r\n\r\n    switch (aggregationType) {\r\n      case AggregationType.SUM:\r\n        const sumResult = await query.select(\"SUM(metric.value)\", \"sum\").getRawOne()\r\n        aggregatedValue = Number.parseFloat(sumResult.sum) || 0\r\n        break\r\n      case AggregationType.AVG:\r\n        const avgResult = await query.select(\"AVG(metric.value)\", \"avg\").getRawOne()\r\n        aggregatedValue = Number.parseFloat(avgResult.avg) || 0\r\n        break\r\n      case AggregationType.COUNT:\r\n        aggregatedValue = await query.getCount()\r\n        break\r\n      case AggregationType.MIN:\r\n        const minResult = await query.select(\"MIN(metric.value)\", \"min\").getRawOne()\r\n        aggregatedValue = Number.parseFloat(minResult.min) || 0\r\n        break\r\n      case AggregationType.MAX:\r\n        const maxResult = await query.select(\"MAX(metric.value)\", \"max\").getRawOne()\r\n        aggregatedValue = Number.parseFloat(maxResult.max) || 0\r\n        break\r\n      default:\r\n        aggregatedValue = 0\r\n    }\r\n\r\n    // Save aggregated metric\r\n    const aggregatedMetric = this.metricRepository.create({\r\n      metricName,\r\n      metricType: MetricType.GAUGE,\r\n      value: aggregatedValue,\r\n      dimensions,\r\n      timestamp: startTime,\r\n      aggregationType,\r\n      granularity,\r\n    })\r\n\r\n    await this.metricRepository.save(aggregatedMetric)\r\n  }\r\n}\r\n"],"version":3}