{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\files\\files.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\files\\files.service.ts"],"sourcesContent":["/**\r\n * FilesService provides logic for file management (upload, download, etc.).\r\n */\r\nimport { Injectable } from '@nestjs/common';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport * as crypto from 'crypto';\r\nimport ffmpeg from 'fluent-ffmpeg';\r\nimport { CloudinaryService } from '../cloudinary/cloudinary.service';\r\nimport { RedisService } from '../shared/services/redis.service';\r\n\r\n@Injectable()\r\nexport class FilesService {\r\n  private readonly tempDir = path.join(process.cwd(), 'uploads', 'tmp');\r\n\r\n  constructor(\r\n    private readonly cloudinaryService: CloudinaryService,\r\n    private readonly redisService: RedisService,\r\n  ) {\r\n    if (!fs.existsSync(this.tempDir)) {\r\n      fs.mkdirSync(this.tempDir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  async saveChunk(\r\n    uploadId: string,\r\n    chunkIndex: number,\r\n    file: Express.Multer.File,\r\n  ) {\r\n    const chunkDir = path.join(this.tempDir, uploadId);\r\n    if (!fs.existsSync(chunkDir)) {\r\n      fs.mkdirSync(chunkDir, { recursive: true });\r\n    }\r\n    const chunkPath = path.join(chunkDir, `${chunkIndex}`);\r\n    await fs.promises.writeFile(chunkPath, file.buffer);\r\n  }\r\n\r\n  /**\r\n   * Assembles file chunks, compresses if video, uploads to Cloudinary, and returns the CDN URL.\r\n   * @returns The Cloudinary CDN URL for the uploaded file\r\n   */\r\n  async assembleChunks(\r\n    uploadId: string,\r\n    fileName: string,\r\n    totalChunks: number,\r\n  ): Promise<string> {\r\n    const chunkDir = path.join(this.tempDir, uploadId);\r\n    const finalPath = path.join(process.cwd(), 'uploads', fileName);\r\n    const writeStream = fs.createWriteStream(finalPath);\r\n    for (let i = 0; i < totalChunks; i++) {\r\n      const chunkPath = path.join(chunkDir, `${i}`);\r\n      const data = await fs.promises.readFile(chunkPath);\r\n      writeStream.write(data);\r\n    }\r\n    writeStream.end();\r\n\r\n    // Wait for the write stream to finish\r\n    await new Promise<void>((resolve) =>\r\n      writeStream.on('finish', () => resolve()),\r\n    );\r\n\r\n    // Cleanup chunks\r\n    const files = await fs.promises.readdir(chunkDir);\r\n    for (const file of files) {\r\n      await fs.promises.unlink(path.join(chunkDir, file));\r\n    }\r\n    await fs.promises.rmdir(chunkDir);\r\n\r\n    // Calculate file hash for deduplication\r\n    const fileBuffer = await fs.promises.readFile(finalPath);\r\n    const hash = crypto.createHash('sha256').update(fileBuffer).digest('hex');\r\n    const redisKey = `filehash:${hash}`;\r\n    const existingUrl = await this.redisService.get(redisKey);\r\n    if (existingUrl) {\r\n      // Remove the just-assembled file since it's a duplicate\r\n      await fs.promises.unlink(finalPath);\r\n      return existingUrl;\r\n    }\r\n\r\n    // If video, compress\r\n    if (this.isVideoFile(fileName)) {\r\n      await this.compressVideo(finalPath);\r\n    }\r\n\r\n    // Upload to Cloudinary and return the CDN URL\r\n    const uploadResult =\r\n      await this.cloudinaryService.uploadVideoFromPath(finalPath);\r\n    // Store hash-to-url mapping in Redis (no expiration)\r\n    await this.redisService.set(redisKey, uploadResult.secure_url);\r\n    return uploadResult.secure_url;\r\n  }\r\n\r\n  /**\r\n   * Checks if a file is a video based on its extension.\r\n   * @param fileName The file name to check\r\n   */\r\n  private isVideoFile(fileName: string): boolean {\r\n    const videoExtensions = ['.mp4', '.mov', '.avi', '.mkv', '.webm'];\r\n    return videoExtensions.includes(path.extname(fileName).toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Compresses a video file using ffmpeg and replaces the original with the compressed version.\r\n   * @param filePath The path to the video file\r\n   */\r\n  private compressVideo(filePath: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const tempCompressed = filePath + '.compressed.mp4';\r\n      ffmpeg(filePath)\r\n        .outputOptions([\r\n          '-vcodec libx264',\r\n          '-crf 28', // Adjust CRF for desired quality/size\r\n          '-preset fast',\r\n          '-acodec aac',\r\n          '-b:a 128k',\r\n        ])\r\n        .on('end', async () => {\r\n          try {\r\n            await fs.promises.rename(tempCompressed, filePath);\r\n            resolve();\r\n          } catch (err) {\r\n            reject(err);\r\n          }\r\n        })\r\n        .on('error', (err) => {\r\n          reject(err);\r\n        })\r\n        .save(tempCompressed);\r\n    });\r\n  }\r\n  /**\r\n   * Returns the upload progress for a given uploadId.\r\n   * Lists which chunks have been received so far.\r\n   */\r\n  async getUploadProgress(uploadId: string, totalChunks?: number) {\r\n    const chunkDir = path.join(this.tempDir, uploadId);\r\n    let receivedChunks: number[] = [];\r\n    if (fs.existsSync(chunkDir)) {\r\n      const files = await fs.promises.readdir(chunkDir);\r\n      receivedChunks = files\r\n        .map((f) => parseInt(f, 10))\r\n        .filter((n) => !isNaN(n));\r\n    }\r\n    return {\r\n      uploadId,\r\n      receivedChunks,\r\n      totalChunks,\r\n    };\r\n  }\r\n}\r\n"],"version":3}