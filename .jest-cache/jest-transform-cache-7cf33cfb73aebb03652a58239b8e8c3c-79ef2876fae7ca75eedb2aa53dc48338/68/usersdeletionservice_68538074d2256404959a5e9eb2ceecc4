f48b69a7a03d0470e04ed72b334101c6
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var UserDeletionService_1;
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserDeletionService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const user_entity_1 = require("../entities/user.entity");
const wallet_info_entity_1 = require("../entities/wallet-info.entity");
const user_progress_entity_1 = require("../entities/user-progress.entity");
const config_1 = require("@nestjs/config");
const accountStatus_enum_1 = require("../enums/accountStatus.enum");
const audit_log_service_1 = require("src/audit/services/audit.log.service");
const account_deletion_confirmation_service_1 = require("./account.deletion.confirmation.service");
/**
 * Service responsible for handling user account deletion process
 */
let UserDeletionService = UserDeletionService_1 = class UserDeletionService {
    constructor(userRepository, walletInfoRepository, userProgressRepository, auditLogService, confirmationService, connection, configService) {
        this.userRepository = userRepository;
        this.walletInfoRepository = walletInfoRepository;
        this.userProgressRepository = userProgressRepository;
        this.auditLogService = auditLogService;
        this.confirmationService = confirmationService;
        this.connection = connection;
        this.configService = configService;
        this.logger = new common_1.Logger(UserDeletionService_1.name);
        // Get data retention period from config (days)
        this.dataRetentionPeriod = this.configService.get('DATA_RETENTION_PERIOD', 30);
    }
    /**
     * Deactivate a user account
     * @param userId User ID to deactivate
     * @param requestingUserId User ID requesting the deactivation
     */
    async deactivateAccount(userId, requestingUserId) {
        const user = await this.findUserOrFail(userId);
        // Begin transaction
        const queryRunner = this.connection.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            // Add status column to track account state
            user['status'] = accountStatus_enum_1.AccountStatus.DEACTIVATED;
            user['deactivatedAt'] = new Date();
            await queryRunner.manager.save(user);
            // Log the deactivation
            await this.auditLogService.createLog({
                action: 'ACCOUNT_DEACTIVATION',
                entityType: 'USER',
                entityId: userId,
                performedBy: requestingUserId,
                details: {
                    timestamp: new Date().toISOString(),
                },
            });
            await queryRunner.commitTransaction();
            this.logger.log(`Account ${userId} has been deactivated`);
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            this.logger.error(`Failed to deactivate account ${userId}`, error.stack);
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    /**
     * Request account deletion and start confirmation workflow
     * @param userId User ID to delete
     * @param requestingUserId User ID requesting the deletion
     */
    async requestAccountDeletion(userId, requestingUserId) {
        const user = await this.findUserOrFail(userId);
        // Ensure user is authorized to delete this account
        if (userId !== requestingUserId) {
            const requestingUser = await this.findUserOrFail(requestingUserId);
            if (requestingUser.role !== 'ADMIN') {
                throw new common_1.BadRequestException('You are not authorized to delete this account');
            }
        }
        // Mark account as pending deletion
        user['status'] = accountStatus_enum_1.AccountStatus.PENDING_DELETION;
        user['deletionRequestedAt'] = new Date();
        await this.userRepository.save(user);
        // Start confirmation workflow
        const confirmationUrl = `${this.configService.get('FRONTEND_URL')}/confirm-deletion?userId=${user.id}`;
        const unsubscribeUrl = `${this.configService.get('FRONTEND_URL')}/preferences?email=${user.email}`;
        await this.confirmationService.sendAccountDeletionEmail({
            email: user.email,
            firstName: user.firstName,
            confirmationUrl,
            unsubscribeUrl,
        });
        // Log deletion request
        await this.auditLogService.createLog({
            action: 'ACCOUNT_DELETION_REQUESTED',
            entityType: 'USER',
            entityId: userId,
            performedBy: requestingUserId,
            details: {
                timestamp: new Date().toISOString(),
            },
        });
        this.logger.log(`Account deletion requested for user ${userId}`);
    }
    /**
     * Confirm account deletion with token
     * @param userId User ID to delete
     * @param confirmationToken Confirmation token
     */
    async confirmAccountDeletion(userId, confirmationToken) {
        // Validate confirmation token
        const isValid = await this.confirmationService.validateAndDeleteAccount(confirmationToken);
        if (!isValid) {
            throw new common_1.BadRequestException('Invalid or expired confirmation token');
        }
        await this.performAccountDeletion(userId, userId);
    }
    /**
     * Perform the actual account deletion process
     * @param userId User ID to delete
     * @param requestingUserId User ID requesting the deletion
     */
    async performAccountDeletion(userId, requestingUserId) {
        const user = await this.findUserOrFail(userId);
        // Begin transaction for atomic operations
        const queryRunner = this.connection.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            // Scrub sensitive user data but preserve the record for soft deletion
            await this.scrubUserData(userId, queryRunner);
            // Preserve blockchain credentials but mark as orphaned
            await this.preserveBlockchainCredentials(userId, queryRunner);
            // Soft delete related entities
            await queryRunner.manager.softDelete(user_progress_entity_1.UserProgress, {
                user: { id: userId },
            });
            // Soft delete the user entity
            user['status'] = accountStatus_enum_1.AccountStatus.DELETED;
            user['deletedAt'] = new Date();
            await queryRunner.manager.save(user);
            // Log the deletion
            await this.auditLogService.createLog({
                action: 'ACCOUNT_DELETED',
                entityType: 'USER',
                entityId: userId,
                performedBy: requestingUserId,
                details: {
                    timestamp: new Date().toISOString(),
                    retentionPeriod: this.dataRetentionPeriod,
                },
            });
            await queryRunner.commitTransaction();
            this.logger.log(`Account ${userId} has been deleted and data scrubbed`);
            // Schedule final purge after retention period
            this.scheduleDataPurge(userId);
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            this.logger.error(`Failed to delete account ${userId}`, error.stack);
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    /**
     * Scrub sensitive user data but preserve the record
     * @param userId User ID to scrub
     * @param queryRunner Transaction query runner
     */
    async scrubUserData(userId, queryRunner) {
        // Keep user ID but scrub personal information
        await queryRunner.manager.update(user_entity_1.User, userId, {
            firstName: '[REDACTED]',
            lastName: '[REDACTED]',
            email: `deleted-${userId}@redacted.user`,
            bio: null,
            profilePicture: null,
            // Don't delete password hash as it's needed for security audit purposes
        });
    }
    /**
     * Preserve blockchain credentials for compliance and access purposes
     * @param userId User ID
     * @param queryRunner Transaction query runner
     */
    async preserveBlockchainCredentials(userId, queryRunner) {
        const walletInfo = await this.walletInfoRepository.findOne({
            where: { user: { id: userId } },
        });
        if (walletInfo) {
            // Mark wallet as orphaned but preserve the blockchain data
            await queryRunner.manager.update(wallet_info_entity_1.WalletInfo, walletInfo.id, {
                orphaned: true,
                orphanedAt: new Date(),
                // Keep blockchain credentials for compliance
            });
            this.logger.log(`Blockchain credentials preserved for user ${userId}`);
        }
    }
    /**
     * Schedule complete data purge after retention period
     * @param userId User ID to purge
     */
    scheduleDataPurge(userId) {
        const purgeDate = new Date();
        purgeDate.setDate(purgeDate.getDate() + this.dataRetentionPeriod);
        this.logger.log(`Scheduling complete data purge for user ${userId} on ${purgeDate.toISOString()}`);
        // For production, you might want to use a job scheduler like Bull
        // This is a simplified version for demonstration
        setTimeout(async () => {
            await this.purgeUserData(userId);
        }, this.dataRetentionPeriod * 24 * 60 * 60 * 1000);
    }
    /**
     * Completely purge user data after retention period
     * @param userId User ID to purge
     */
    async purgeUserData(userId) {
        const queryRunner = this.connection.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            // Hard delete related entities first
            await queryRunner.manager.delete(user_progress_entity_1.UserProgress, { user: { id: userId } });
            // Check if blockchain credentials should be permanently deleted
            // This depends on your regulatory requirements
            const walletInfo = await this.walletInfoRepository.findOne({
                where: { user: { id: userId } },
            });
            if (walletInfo && this.shouldPurgeBlockchainData(walletInfo)) {
                await queryRunner.manager.delete(wallet_info_entity_1.WalletInfo, walletInfo.id);
            }
            // Finally hard delete the user
            await queryRunner.manager.delete(user_entity_1.User, userId);
            await queryRunner.commitTransaction();
            // Log the permanent deletion
            await this.auditLogService.createLog({
                action: 'ACCOUNT_PURGED',
                entityType: 'USER',
                entityId: userId,
                performedBy: 'SYSTEM',
                details: {
                    timestamp: new Date().toISOString(),
                },
            });
            this.logger.log(`User data for ${userId} has been permanently purged`);
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            this.logger.error(`Failed to purge user data for ${userId}`, error.stack);
            throw error;
        }
        finally {
            await queryRunner.release();
        }
    }
    /**
     * Determine if blockchain data should be purged based on regulations
     * @param walletInfo Wallet information
     */
    shouldPurgeBlockchainData(walletInfo) {
        // This logic should be implemented based on your specific regulatory requirements
        // For example, you might need to keep some data for tax purposes
        // GDPR allows keeping data needed for legal obligations
        // For demonstration, we're returning false to preserve blockchain data
        return false;
    }
    /**
     * Utility method to find a user or throw exception
     * @param userId User ID to find
     */
    async findUserOrFail(userId) {
        const user = await this.userRepository.findOne({
            where: { id: userId },
        });
        if (!user) {
            throw new common_1.NotFoundException(`User with ID ${userId} not found`);
        }
        return user;
    }
};
exports.UserDeletionService = UserDeletionService;
exports.UserDeletionService = UserDeletionService = UserDeletionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __param(1, (0, typeorm_1.InjectRepository)(wallet_info_entity_1.WalletInfo)),
    __param(2, (0, typeorm_1.InjectRepository)(user_progress_entity_1.UserProgress)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof audit_log_service_1.AuditLogService !== "undefined" && audit_log_service_1.AuditLogService) === "function" ? _d : Object, typeof (_e = typeof account_deletion_confirmation_service_1.AccountDeletionConfirmationService !== "undefined" && account_deletion_confirmation_service_1.AccountDeletionConfirmationService) === "function" ? _e : Object, typeof (_f = typeof typeorm_2.Connection !== "undefined" && typeorm_2.Connection) === "function" ? _f : Object, typeof (_g = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _g : Object])
], UserDeletionService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxvam9zZXBoXFxEb2N1bWVudHNcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFx1c2Vyc1xcc2VydmljZXNcXHVzZXJzLmRlbGV0aW9uLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FLd0I7QUFDeEIsNkNBQW1EO0FBQ25ELHFDQUFpRDtBQUNqRCx5REFBK0M7QUFDL0MsdUVBQTREO0FBQzVELDJFQUFnRTtBQUNoRSwyQ0FBK0M7QUFDL0Msb0VBQTREO0FBQzVELDRFQUF1RTtBQUN2RSxtR0FBNkY7QUFJN0Y7O0dBRUc7QUFFSSxJQUFNLG1CQUFtQiwyQkFBekIsTUFBTSxtQkFBbUI7SUFJOUIsWUFFRSxjQUFpRCxFQUVqRCxvQkFBNkQsRUFFN0Qsc0JBQWlFLEVBQ2hELGVBQWdDLEVBQ2hDLG1CQUF1RCxFQUN2RCxVQUFzQixFQUN0QixhQUE0QjtRQVI1QixtQkFBYyxHQUFkLGNBQWMsQ0FBa0I7UUFFaEMseUJBQW9CLEdBQXBCLG9CQUFvQixDQUF3QjtRQUU1QywyQkFBc0IsR0FBdEIsc0JBQXNCLENBQTBCO1FBQ2hELG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQUNoQyx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQW9DO1FBQ3ZELGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFiOUIsV0FBTSxHQUFHLElBQUksZUFBTSxDQUFDLHFCQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBZTdELCtDQUErQztRQUMvQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQy9DLHVCQUF1QixFQUN2QixFQUFFLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGlCQUFpQixDQUNyQixNQUFjLEVBQ2QsZ0JBQXdCO1FBRXhCLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUvQyxvQkFBb0I7UUFDcEIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hELE1BQU0sV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzVCLE1BQU0sV0FBVyxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFFckMsSUFBSSxDQUFDO1lBQ0gsMkNBQTJDO1lBQzNDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxrQ0FBYSxDQUFDLFdBQVcsQ0FBQztZQUMzQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUVuQyxNQUFNLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXJDLHVCQUF1QjtZQUN2QixNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDO2dCQUNuQyxNQUFNLEVBQUUsc0JBQXNCO2dCQUM5QixVQUFVLEVBQUUsTUFBTTtnQkFDbEIsUUFBUSxFQUFFLE1BQU07Z0JBQ2hCLFdBQVcsRUFBRSxnQkFBZ0I7Z0JBQzdCLE9BQU8sRUFBRTtvQkFDUCxTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUU7aUJBQ3BDO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsTUFBTSxXQUFXLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLE1BQU0sdUJBQXVCLENBQUMsQ0FBQztRQUM1RCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE1BQU0sV0FBVyxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDeEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLE1BQU0sRUFBRSxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6RSxNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7Z0JBQVMsQ0FBQztZQUNULE1BQU0sV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzlCLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxzQkFBc0IsQ0FDMUIsTUFBYyxFQUNkLGdCQUF3QjtRQUV4QixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFL0MsbURBQW1EO1FBQ25ELElBQUksTUFBTSxLQUFLLGdCQUFnQixFQUFFLENBQUM7WUFDaEMsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDbkUsSUFBSSxjQUFjLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRSxDQUFDO2dCQUNwQyxNQUFNLElBQUksNEJBQW1CLENBQzNCLCtDQUErQyxDQUNoRCxDQUFDO1lBQ0osQ0FBQztRQUNILENBQUM7UUFFRCxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLGtDQUFhLENBQUMsZ0JBQWdCLENBQUM7UUFDaEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN6QyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLDhCQUE4QjtRQUM5QixNQUFNLGVBQWUsR0FBRyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFTLGNBQWMsQ0FBQyw0QkFBNEIsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQy9HLE1BQU0sY0FBYyxHQUFHLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQVMsY0FBYyxDQUFDLHNCQUFzQixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFM0csTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsd0JBQXdCLENBQUM7WUFDdEQsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1lBQ2pCLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixlQUFlO1lBQ2YsY0FBYztTQUNmLENBQUMsQ0FBQztRQUVILHVCQUF1QjtRQUN2QixNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDO1lBQ25DLE1BQU0sRUFBRSw0QkFBNEI7WUFDcEMsVUFBVSxFQUFFLE1BQU07WUFDbEIsUUFBUSxFQUFFLE1BQU07WUFDaEIsV0FBVyxFQUFFLGdCQUFnQjtZQUM3QixPQUFPLEVBQUU7Z0JBQ1AsU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO2FBQ3BDO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsdUNBQXVDLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsc0JBQXNCLENBQzFCLE1BQWMsRUFDZCxpQkFBeUI7UUFFekIsOEJBQThCO1FBQzlCLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLHdCQUF3QixDQUFDLGlCQUFpQixDQUN4RixDQUFDO1FBRUYsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2IsTUFBTSxJQUFJLDRCQUFtQixDQUFDLHVDQUF1QyxDQUFDLENBQUM7UUFDekUsQ0FBQztRQUVELE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxzQkFBc0IsQ0FDMUIsTUFBYyxFQUNkLGdCQUF3QjtRQUV4QixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFL0MsMENBQTBDO1FBQzFDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4RCxNQUFNLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM1QixNQUFNLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRXJDLElBQUksQ0FBQztZQUNILHNFQUFzRTtZQUN0RSxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBRTlDLHVEQUF1RDtZQUN2RCxNQUFNLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFFOUQsK0JBQStCO1lBQy9CLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsbUNBQVksRUFBRTtnQkFDakQsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRTthQUNyQixDQUFDLENBQUM7WUFFSCw4QkFBOEI7WUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLGtDQUFhLENBQUMsT0FBTyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQy9CLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFckMsbUJBQW1CO1lBQ25CLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUM7Z0JBQ25DLE1BQU0sRUFBRSxpQkFBaUI7Z0JBQ3pCLFVBQVUsRUFBRSxNQUFNO2dCQUNsQixRQUFRLEVBQUUsTUFBTTtnQkFDaEIsV0FBVyxFQUFFLGdCQUFnQjtnQkFDN0IsT0FBTyxFQUFFO29CQUNQLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRTtvQkFDbkMsZUFBZSxFQUFFLElBQUksQ0FBQyxtQkFBbUI7aUJBQzFDO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsTUFBTSxXQUFXLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLE1BQU0scUNBQXFDLENBQUMsQ0FBQztZQUV4RSw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsTUFBTSxXQUFXLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUN4QyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsTUFBTSxFQUFFLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztnQkFBUyxDQUFDO1lBQ1QsTUFBTSxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDOUIsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLGFBQWEsQ0FBQyxNQUFjLEVBQUUsV0FBZ0I7UUFDMUQsOENBQThDO1FBQzlDLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsa0JBQUksRUFBRSxNQUFNLEVBQUU7WUFDN0MsU0FBUyxFQUFFLFlBQVk7WUFDdkIsUUFBUSxFQUFFLFlBQVk7WUFDdEIsS0FBSyxFQUFFLFdBQVcsTUFBTSxnQkFBZ0I7WUFDeEMsR0FBRyxFQUFFLElBQUk7WUFDVCxjQUFjLEVBQUUsSUFBSTtZQUNwQix3RUFBd0U7U0FDekUsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMsNkJBQTZCLENBQ3pDLE1BQWMsRUFDZCxXQUFnQjtRQUVoQixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUM7WUFDekQsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFO1NBQ2hDLENBQUMsQ0FBQztRQUVILElBQUksVUFBVSxFQUFFLENBQUM7WUFDZiwyREFBMkQ7WUFDM0QsTUFBTSxXQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQywrQkFBVSxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzFELFFBQVEsRUFBRSxJQUFJO2dCQUNkLFVBQVUsRUFBRSxJQUFJLElBQUksRUFBRTtnQkFDdEIsNkNBQTZDO2FBQzlDLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLDZDQUE2QyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLENBQUM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssaUJBQWlCLENBQUMsTUFBYztRQUN0QyxNQUFNLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQzdCLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBRWxFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUNiLDJDQUEyQyxNQUFNLE9BQU8sU0FBUyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQ2xGLENBQUM7UUFFRixrRUFBa0U7UUFDbEUsaURBQWlEO1FBQ2pELFVBQVUsQ0FDUixLQUFLLElBQUksRUFBRTtZQUNULE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuQyxDQUFDLEVBQ0QsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FDL0MsQ0FBQztJQUNKLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUFDLE1BQWM7UUFDaEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hELE1BQU0sV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzVCLE1BQU0sV0FBVyxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFFckMsSUFBSSxDQUFDO1lBQ0gscUNBQXFDO1lBQ3JDLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsbUNBQVksRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFekUsZ0VBQWdFO1lBQ2hFLCtDQUErQztZQUMvQyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUM7Z0JBQ3pELEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRTthQUNoQyxDQUFDLENBQUM7WUFFSCxJQUFJLFVBQVUsSUFBSSxJQUFJLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztnQkFDN0QsTUFBTSxXQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQywrQkFBVSxFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM5RCxDQUFDO1lBRUQsK0JBQStCO1lBQy9CLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsa0JBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztZQUUvQyxNQUFNLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBRXRDLDZCQUE2QjtZQUM3QixNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDO2dCQUNuQyxNQUFNLEVBQUUsZ0JBQWdCO2dCQUN4QixVQUFVLEVBQUUsTUFBTTtnQkFDbEIsUUFBUSxFQUFFLE1BQU07Z0JBQ2hCLFdBQVcsRUFBRSxRQUFRO2dCQUNyQixPQUFPLEVBQUU7b0JBQ1AsU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO2lCQUNwQzthQUNGLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGlCQUFpQixNQUFNLDhCQUE4QixDQUFDLENBQUM7UUFDekUsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixNQUFNLFdBQVcsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1lBQ3hDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGlDQUFpQyxNQUFNLEVBQUUsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUUsTUFBTSxLQUFLLENBQUM7UUFDZCxDQUFDO2dCQUFTLENBQUM7WUFDVCxNQUFNLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5QixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNLLHlCQUF5QixDQUFDLFVBQXNCO1FBQ3RELGtGQUFrRjtRQUNsRixpRUFBaUU7UUFDakUsd0RBQXdEO1FBRXhELHVFQUF1RTtRQUN2RSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7O09BR0c7SUFDSyxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQWM7UUFDekMsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQztZQUM3QyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFO1NBQ3RCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLE1BQU0sSUFBSSwwQkFBaUIsQ0FBQyxnQkFBZ0IsTUFBTSxZQUFZLENBQUMsQ0FBQztRQUNsRSxDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0YsQ0FBQTtBQW5WWSxrREFBbUI7OEJBQW5CLG1CQUFtQjtJQUQvQixJQUFBLG1CQUFVLEdBQUU7SUFNUixXQUFBLElBQUEsMEJBQWdCLEVBQUMsa0JBQUksQ0FBQyxDQUFBO0lBRXRCLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQywrQkFBVSxDQUFDLENBQUE7SUFFNUIsV0FBQSxJQUFBLDBCQUFnQixFQUFDLG1DQUFZLENBQUMsQ0FBQTt5REFIRSxvQkFBVSxvQkFBVixvQkFBVSxvREFFSixvQkFBVSxvQkFBVixvQkFBVSxvREFFUixvQkFBVSxvQkFBVixvQkFBVSxvREFDakIsbUNBQWUsb0JBQWYsbUNBQWUsb0RBQ1gsMEVBQWtDLG9CQUFsQywwRUFBa0Msb0RBQzNDLG9CQUFVLG9CQUFWLG9CQUFVLG9EQUNQLHNCQUFhLG9CQUFiLHNCQUFhO0dBZHBDLG1CQUFtQixDQW1WL0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxvam9zZXBoXFxEb2N1bWVudHNcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFx1c2Vyc1xcc2VydmljZXNcXHVzZXJzLmRlbGV0aW9uLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBJbmplY3RhYmxlLFxyXG4gIExvZ2dlcixcclxuICBOb3RGb3VuZEV4Y2VwdGlvbixcclxuICBCYWRSZXF1ZXN0RXhjZXB0aW9uLFxyXG59IGZyb20gJ0BuZXN0anMvY29tbW9uJztcclxuaW1wb3J0IHsgSW5qZWN0UmVwb3NpdG9yeSB9IGZyb20gJ0BuZXN0anMvdHlwZW9ybSc7XHJcbmltcG9ydCB7IFJlcG9zaXRvcnksIENvbm5lY3Rpb24gfSBmcm9tICd0eXBlb3JtJztcclxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uL2VudGl0aWVzL3VzZXIuZW50aXR5JztcclxuaW1wb3J0IHsgV2FsbGV0SW5mbyB9IGZyb20gJy4uL2VudGl0aWVzL3dhbGxldC1pbmZvLmVudGl0eSc7XHJcbmltcG9ydCB7IFVzZXJQcm9ncmVzcyB9IGZyb20gJy4uL2VudGl0aWVzL3VzZXItcHJvZ3Jlc3MuZW50aXR5JztcclxuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcclxuaW1wb3J0IHsgQWNjb3VudFN0YXR1cyB9IGZyb20gJy4uL2VudW1zL2FjY291bnRTdGF0dXMuZW51bSc7XHJcbmltcG9ydCB7IEF1ZGl0TG9nU2VydmljZSB9IGZyb20gJ3NyYy9hdWRpdC9zZXJ2aWNlcy9hdWRpdC5sb2cuc2VydmljZSc7XHJcbmltcG9ydCB7IEFjY291bnREZWxldGlvbkNvbmZpcm1hdGlvblNlcnZpY2UgfSBmcm9tICcuL2FjY291bnQuZGVsZXRpb24uY29uZmlybWF0aW9uLnNlcnZpY2UnO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogU2VydmljZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdXNlciBhY2NvdW50IGRlbGV0aW9uIHByb2Nlc3NcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFVzZXJEZWxldGlvblNlcnZpY2Uge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihVc2VyRGVsZXRpb25TZXJ2aWNlLm5hbWUpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZGF0YVJldGVudGlvblBlcmlvZDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3RSZXBvc2l0b3J5KFVzZXIpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHVzZXJSZXBvc2l0b3J5OiBSZXBvc2l0b3J5PFVzZXI+LFxyXG4gICAgQEluamVjdFJlcG9zaXRvcnkoV2FsbGV0SW5mbylcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgd2FsbGV0SW5mb1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8V2FsbGV0SW5mbz4sXHJcbiAgICBASW5qZWN0UmVwb3NpdG9yeShVc2VyUHJvZ3Jlc3MpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHVzZXJQcm9ncmVzc1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8VXNlclByb2dyZXNzPixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXVkaXRMb2dTZXJ2aWNlOiBBdWRpdExvZ1NlcnZpY2UsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpcm1hdGlvblNlcnZpY2U6IEFjY291bnREZWxldGlvbkNvbmZpcm1hdGlvblNlcnZpY2UsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZ1NlcnZpY2U6IENvbmZpZ1NlcnZpY2UsXHJcbiAgKSB7XHJcbiAgICAvLyBHZXQgZGF0YSByZXRlbnRpb24gcGVyaW9kIGZyb20gY29uZmlnIChkYXlzKVxyXG4gICAgdGhpcy5kYXRhUmV0ZW50aW9uUGVyaW9kID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldDxudW1iZXI+KFxyXG4gICAgICAnREFUQV9SRVRFTlRJT05fUEVSSU9EJyxcclxuICAgICAgMzAsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVhY3RpdmF0ZSBhIHVzZXIgYWNjb3VudFxyXG4gICAqIEBwYXJhbSB1c2VySWQgVXNlciBJRCB0byBkZWFjdGl2YXRlXHJcbiAgICogQHBhcmFtIHJlcXVlc3RpbmdVc2VySWQgVXNlciBJRCByZXF1ZXN0aW5nIHRoZSBkZWFjdGl2YXRpb25cclxuICAgKi9cclxuICBhc3luYyBkZWFjdGl2YXRlQWNjb3VudChcclxuICAgIHVzZXJJZDogc3RyaW5nLFxyXG4gICAgcmVxdWVzdGluZ1VzZXJJZDogc3RyaW5nLFxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuZmluZFVzZXJPckZhaWwodXNlcklkKTtcclxuXHJcbiAgICAvLyBCZWdpbiB0cmFuc2FjdGlvblxyXG4gICAgY29uc3QgcXVlcnlSdW5uZXIgPSB0aGlzLmNvbm5lY3Rpb24uY3JlYXRlUXVlcnlSdW5uZXIoKTtcclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLmNvbm5lY3QoKTtcclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLnN0YXJ0VHJhbnNhY3Rpb24oKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBBZGQgc3RhdHVzIGNvbHVtbiB0byB0cmFjayBhY2NvdW50IHN0YXRlXHJcbiAgICAgIHVzZXJbJ3N0YXR1cyddID0gQWNjb3VudFN0YXR1cy5ERUFDVElWQVRFRDtcclxuICAgICAgdXNlclsnZGVhY3RpdmF0ZWRBdCddID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgIGF3YWl0IHF1ZXJ5UnVubmVyLm1hbmFnZXIuc2F2ZSh1c2VyKTtcclxuXHJcbiAgICAgIC8vIExvZyB0aGUgZGVhY3RpdmF0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMuYXVkaXRMb2dTZXJ2aWNlLmNyZWF0ZUxvZyh7XHJcbiAgICAgICAgYWN0aW9uOiAnQUNDT1VOVF9ERUFDVElWQVRJT04nLFxyXG4gICAgICAgIGVudGl0eVR5cGU6ICdVU0VSJyxcclxuICAgICAgICBlbnRpdHlJZDogdXNlcklkLFxyXG4gICAgICAgIHBlcmZvcm1lZEJ5OiByZXF1ZXN0aW5nVXNlcklkLFxyXG4gICAgICAgIGRldGFpbHM6IHtcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIuY29tbWl0VHJhbnNhY3Rpb24oKTtcclxuICAgICAgdGhpcy5sb2dnZXIubG9nKGBBY2NvdW50ICR7dXNlcklkfSBoYXMgYmVlbiBkZWFjdGl2YXRlZGApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIucm9sbGJhY2tUcmFuc2FjdGlvbigpO1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGRlYWN0aXZhdGUgYWNjb3VudCAke3VzZXJJZH1gLCBlcnJvci5zdGFjayk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIucmVsZWFzZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVxdWVzdCBhY2NvdW50IGRlbGV0aW9uIGFuZCBzdGFydCBjb25maXJtYXRpb24gd29ya2Zsb3dcclxuICAgKiBAcGFyYW0gdXNlcklkIFVzZXIgSUQgdG8gZGVsZXRlXHJcbiAgICogQHBhcmFtIHJlcXVlc3RpbmdVc2VySWQgVXNlciBJRCByZXF1ZXN0aW5nIHRoZSBkZWxldGlvblxyXG4gICAqL1xyXG4gIGFzeW5jIHJlcXVlc3RBY2NvdW50RGVsZXRpb24oXHJcbiAgICB1c2VySWQ6IHN0cmluZyxcclxuICAgIHJlcXVlc3RpbmdVc2VySWQ6IHN0cmluZyxcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmZpbmRVc2VyT3JGYWlsKHVzZXJJZCk7XHJcblxyXG4gICAgLy8gRW5zdXJlIHVzZXIgaXMgYXV0aG9yaXplZCB0byBkZWxldGUgdGhpcyBhY2NvdW50XHJcbiAgICBpZiAodXNlcklkICE9PSByZXF1ZXN0aW5nVXNlcklkKSB7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3RpbmdVc2VyID0gYXdhaXQgdGhpcy5maW5kVXNlck9yRmFpbChyZXF1ZXN0aW5nVXNlcklkKTtcclxuICAgICAgaWYgKHJlcXVlc3RpbmdVc2VyLnJvbGUgIT09ICdBRE1JTicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbihcclxuICAgICAgICAgICdZb3UgYXJlIG5vdCBhdXRob3JpemVkIHRvIGRlbGV0ZSB0aGlzIGFjY291bnQnLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNYXJrIGFjY291bnQgYXMgcGVuZGluZyBkZWxldGlvblxyXG4gICAgdXNlclsnc3RhdHVzJ10gPSBBY2NvdW50U3RhdHVzLlBFTkRJTkdfREVMRVRJT047XHJcbiAgICB1c2VyWydkZWxldGlvblJlcXVlc3RlZEF0J10gPSBuZXcgRGF0ZSgpO1xyXG4gICAgYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5zYXZlKHVzZXIpO1xyXG5cclxuICAgIC8vIFN0YXJ0IGNvbmZpcm1hdGlvbiB3b3JrZmxvd1xyXG4gICAgY29uc3QgY29uZmlybWF0aW9uVXJsID0gYCR7dGhpcy5jb25maWdTZXJ2aWNlLmdldDxzdHJpbmc+KCdGUk9OVEVORF9VUkwnKX0vY29uZmlybS1kZWxldGlvbj91c2VySWQ9JHt1c2VyLmlkfWA7XHJcbiAgICBjb25zdCB1bnN1YnNjcmliZVVybCA9IGAke3RoaXMuY29uZmlnU2VydmljZS5nZXQ8c3RyaW5nPignRlJPTlRFTkRfVVJMJyl9L3ByZWZlcmVuY2VzP2VtYWlsPSR7dXNlci5lbWFpbH1gO1xyXG5cclxuICAgIGF3YWl0IHRoaXMuY29uZmlybWF0aW9uU2VydmljZS5zZW5kQWNjb3VudERlbGV0aW9uRW1haWwoe1xyXG4gICAgICBlbWFpbDogdXNlci5lbWFpbCxcclxuICAgICAgZmlyc3ROYW1lOiB1c2VyLmZpcnN0TmFtZSxcclxuICAgICAgY29uZmlybWF0aW9uVXJsLFxyXG4gICAgICB1bnN1YnNjcmliZVVybCxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExvZyBkZWxldGlvbiByZXF1ZXN0XHJcbiAgICBhd2FpdCB0aGlzLmF1ZGl0TG9nU2VydmljZS5jcmVhdGVMb2coe1xyXG4gICAgICBhY3Rpb246ICdBQ0NPVU5UX0RFTEVUSU9OX1JFUVVFU1RFRCcsXHJcbiAgICAgIGVudGl0eVR5cGU6ICdVU0VSJyxcclxuICAgICAgZW50aXR5SWQ6IHVzZXJJZCxcclxuICAgICAgcGVyZm9ybWVkQnk6IHJlcXVlc3RpbmdVc2VySWQsXHJcbiAgICAgIGRldGFpbHM6IHtcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMubG9nZ2VyLmxvZyhgQWNjb3VudCBkZWxldGlvbiByZXF1ZXN0ZWQgZm9yIHVzZXIgJHt1c2VySWR9YCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maXJtIGFjY291bnQgZGVsZXRpb24gd2l0aCB0b2tlblxyXG4gICAqIEBwYXJhbSB1c2VySWQgVXNlciBJRCB0byBkZWxldGVcclxuICAgKiBAcGFyYW0gY29uZmlybWF0aW9uVG9rZW4gQ29uZmlybWF0aW9uIHRva2VuXHJcbiAgICovXHJcbiAgYXN5bmMgY29uZmlybUFjY291bnREZWxldGlvbihcclxuICAgIHVzZXJJZDogc3RyaW5nLFxyXG4gICAgY29uZmlybWF0aW9uVG9rZW46IHN0cmluZyxcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIFZhbGlkYXRlIGNvbmZpcm1hdGlvbiB0b2tlblxyXG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHRoaXMuY29uZmlybWF0aW9uU2VydmljZS52YWxpZGF0ZUFuZERlbGV0ZUFjY291bnQoY29uZmlybWF0aW9uVG9rZW4sXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbignSW52YWxpZCBvciBleHBpcmVkIGNvbmZpcm1hdGlvbiB0b2tlbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGF3YWl0IHRoaXMucGVyZm9ybUFjY291bnREZWxldGlvbih1c2VySWQsIHVzZXJJZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgYWNjb3VudCBkZWxldGlvbiBwcm9jZXNzXHJcbiAgICogQHBhcmFtIHVzZXJJZCBVc2VyIElEIHRvIGRlbGV0ZVxyXG4gICAqIEBwYXJhbSByZXF1ZXN0aW5nVXNlcklkIFVzZXIgSUQgcmVxdWVzdGluZyB0aGUgZGVsZXRpb25cclxuICAgKi9cclxuICBhc3luYyBwZXJmb3JtQWNjb3VudERlbGV0aW9uKFxyXG4gICAgdXNlcklkOiBzdHJpbmcsXHJcbiAgICByZXF1ZXN0aW5nVXNlcklkOiBzdHJpbmcsXHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5maW5kVXNlck9yRmFpbCh1c2VySWQpO1xyXG5cclxuICAgIC8vIEJlZ2luIHRyYW5zYWN0aW9uIGZvciBhdG9taWMgb3BlcmF0aW9uc1xyXG4gICAgY29uc3QgcXVlcnlSdW5uZXIgPSB0aGlzLmNvbm5lY3Rpb24uY3JlYXRlUXVlcnlSdW5uZXIoKTtcclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLmNvbm5lY3QoKTtcclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLnN0YXJ0VHJhbnNhY3Rpb24oKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTY3J1YiBzZW5zaXRpdmUgdXNlciBkYXRhIGJ1dCBwcmVzZXJ2ZSB0aGUgcmVjb3JkIGZvciBzb2Z0IGRlbGV0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMuc2NydWJVc2VyRGF0YSh1c2VySWQsIHF1ZXJ5UnVubmVyKTtcclxuXHJcbiAgICAgIC8vIFByZXNlcnZlIGJsb2NrY2hhaW4gY3JlZGVudGlhbHMgYnV0IG1hcmsgYXMgb3JwaGFuZWRcclxuICAgICAgYXdhaXQgdGhpcy5wcmVzZXJ2ZUJsb2NrY2hhaW5DcmVkZW50aWFscyh1c2VySWQsIHF1ZXJ5UnVubmVyKTtcclxuXHJcbiAgICAgIC8vIFNvZnQgZGVsZXRlIHJlbGF0ZWQgZW50aXRpZXNcclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIubWFuYWdlci5zb2Z0RGVsZXRlKFVzZXJQcm9ncmVzcywge1xyXG4gICAgICAgIHVzZXI6IHsgaWQ6IHVzZXJJZCB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFNvZnQgZGVsZXRlIHRoZSB1c2VyIGVudGl0eVxyXG4gICAgICB1c2VyWydzdGF0dXMnXSA9IEFjY291bnRTdGF0dXMuREVMRVRFRDtcclxuICAgICAgdXNlclsnZGVsZXRlZEF0J10gPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBhd2FpdCBxdWVyeVJ1bm5lci5tYW5hZ2VyLnNhdmUodXNlcik7XHJcblxyXG4gICAgICAvLyBMb2cgdGhlIGRlbGV0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMuYXVkaXRMb2dTZXJ2aWNlLmNyZWF0ZUxvZyh7XHJcbiAgICAgICAgYWN0aW9uOiAnQUNDT1VOVF9ERUxFVEVEJyxcclxuICAgICAgICBlbnRpdHlUeXBlOiAnVVNFUicsXHJcbiAgICAgICAgZW50aXR5SWQ6IHVzZXJJZCxcclxuICAgICAgICBwZXJmb3JtZWRCeTogcmVxdWVzdGluZ1VzZXJJZCxcclxuICAgICAgICBkZXRhaWxzOiB7XHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIHJldGVudGlvblBlcmlvZDogdGhpcy5kYXRhUmV0ZW50aW9uUGVyaW9kLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIuY29tbWl0VHJhbnNhY3Rpb24oKTtcclxuICAgICAgdGhpcy5sb2dnZXIubG9nKGBBY2NvdW50ICR7dXNlcklkfSBoYXMgYmVlbiBkZWxldGVkIGFuZCBkYXRhIHNjcnViYmVkYCk7XHJcblxyXG4gICAgICAvLyBTY2hlZHVsZSBmaW5hbCBwdXJnZSBhZnRlciByZXRlbnRpb24gcGVyaW9kXHJcbiAgICAgIHRoaXMuc2NoZWR1bGVEYXRhUHVyZ2UodXNlcklkKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGF3YWl0IHF1ZXJ5UnVubmVyLnJvbGxiYWNrVHJhbnNhY3Rpb24oKTtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZWxldGUgYWNjb3VudCAke3VzZXJJZH1gLCBlcnJvci5zdGFjayk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIucmVsZWFzZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NydWIgc2Vuc2l0aXZlIHVzZXIgZGF0YSBidXQgcHJlc2VydmUgdGhlIHJlY29yZFxyXG4gICAqIEBwYXJhbSB1c2VySWQgVXNlciBJRCB0byBzY3J1YlxyXG4gICAqIEBwYXJhbSBxdWVyeVJ1bm5lciBUcmFuc2FjdGlvbiBxdWVyeSBydW5uZXJcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHNjcnViVXNlckRhdGEodXNlcklkOiBzdHJpbmcsIHF1ZXJ5UnVubmVyOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIEtlZXAgdXNlciBJRCBidXQgc2NydWIgcGVyc29uYWwgaW5mb3JtYXRpb25cclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLm1hbmFnZXIudXBkYXRlKFVzZXIsIHVzZXJJZCwge1xyXG4gICAgICBmaXJzdE5hbWU6ICdbUkVEQUNURURdJyxcclxuICAgICAgbGFzdE5hbWU6ICdbUkVEQUNURURdJyxcclxuICAgICAgZW1haWw6IGBkZWxldGVkLSR7dXNlcklkfUByZWRhY3RlZC51c2VyYCxcclxuICAgICAgYmlvOiBudWxsLFxyXG4gICAgICBwcm9maWxlUGljdHVyZTogbnVsbCxcclxuICAgICAgLy8gRG9uJ3QgZGVsZXRlIHBhc3N3b3JkIGhhc2ggYXMgaXQncyBuZWVkZWQgZm9yIHNlY3VyaXR5IGF1ZGl0IHB1cnBvc2VzXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXNlcnZlIGJsb2NrY2hhaW4gY3JlZGVudGlhbHMgZm9yIGNvbXBsaWFuY2UgYW5kIGFjY2VzcyBwdXJwb3Nlc1xyXG4gICAqIEBwYXJhbSB1c2VySWQgVXNlciBJRFxyXG4gICAqIEBwYXJhbSBxdWVyeVJ1bm5lciBUcmFuc2FjdGlvbiBxdWVyeSBydW5uZXJcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHByZXNlcnZlQmxvY2tjaGFpbkNyZWRlbnRpYWxzKFxyXG4gICAgdXNlcklkOiBzdHJpbmcsXHJcbiAgICBxdWVyeVJ1bm5lcjogYW55LFxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3Qgd2FsbGV0SW5mbyA9IGF3YWl0IHRoaXMud2FsbGV0SW5mb1JlcG9zaXRvcnkuZmluZE9uZSh7XHJcbiAgICAgIHdoZXJlOiB7IHVzZXI6IHsgaWQ6IHVzZXJJZCB9IH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAod2FsbGV0SW5mbykge1xyXG4gICAgICAvLyBNYXJrIHdhbGxldCBhcyBvcnBoYW5lZCBidXQgcHJlc2VydmUgdGhlIGJsb2NrY2hhaW4gZGF0YVxyXG4gICAgICBhd2FpdCBxdWVyeVJ1bm5lci5tYW5hZ2VyLnVwZGF0ZShXYWxsZXRJbmZvLCB3YWxsZXRJbmZvLmlkLCB7XHJcbiAgICAgICAgb3JwaGFuZWQ6IHRydWUsXHJcbiAgICAgICAgb3JwaGFuZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICAvLyBLZWVwIGJsb2NrY2hhaW4gY3JlZGVudGlhbHMgZm9yIGNvbXBsaWFuY2VcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5sb2coYEJsb2NrY2hhaW4gY3JlZGVudGlhbHMgcHJlc2VydmVkIGZvciB1c2VyICR7dXNlcklkfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NoZWR1bGUgY29tcGxldGUgZGF0YSBwdXJnZSBhZnRlciByZXRlbnRpb24gcGVyaW9kXHJcbiAgICogQHBhcmFtIHVzZXJJZCBVc2VyIElEIHRvIHB1cmdlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzY2hlZHVsZURhdGFQdXJnZSh1c2VySWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgY29uc3QgcHVyZ2VEYXRlID0gbmV3IERhdGUoKTtcclxuICAgIHB1cmdlRGF0ZS5zZXREYXRlKHB1cmdlRGF0ZS5nZXREYXRlKCkgKyB0aGlzLmRhdGFSZXRlbnRpb25QZXJpb2QpO1xyXG5cclxuICAgIHRoaXMubG9nZ2VyLmxvZyhcclxuICAgICAgYFNjaGVkdWxpbmcgY29tcGxldGUgZGF0YSBwdXJnZSBmb3IgdXNlciAke3VzZXJJZH0gb24gJHtwdXJnZURhdGUudG9JU09TdHJpbmcoKX1gLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBGb3IgcHJvZHVjdGlvbiwgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgam9iIHNjaGVkdWxlciBsaWtlIEJ1bGxcclxuICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb24gZm9yIGRlbW9uc3RyYXRpb25cclxuICAgIHNldFRpbWVvdXQoXHJcbiAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLnB1cmdlVXNlckRhdGEodXNlcklkKTtcclxuICAgICAgfSxcclxuICAgICAgdGhpcy5kYXRhUmV0ZW50aW9uUGVyaW9kICogMjQgKiA2MCAqIDYwICogMTAwMCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wbGV0ZWx5IHB1cmdlIHVzZXIgZGF0YSBhZnRlciByZXRlbnRpb24gcGVyaW9kXHJcbiAgICogQHBhcmFtIHVzZXJJZCBVc2VyIElEIHRvIHB1cmdlXHJcbiAgICovXHJcbiAgYXN5bmMgcHVyZ2VVc2VyRGF0YSh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgcXVlcnlSdW5uZXIgPSB0aGlzLmNvbm5lY3Rpb24uY3JlYXRlUXVlcnlSdW5uZXIoKTtcclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLmNvbm5lY3QoKTtcclxuICAgIGF3YWl0IHF1ZXJ5UnVubmVyLnN0YXJ0VHJhbnNhY3Rpb24oKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBIYXJkIGRlbGV0ZSByZWxhdGVkIGVudGl0aWVzIGZpcnN0XHJcbiAgICAgIGF3YWl0IHF1ZXJ5UnVubmVyLm1hbmFnZXIuZGVsZXRlKFVzZXJQcm9ncmVzcywgeyB1c2VyOiB7IGlkOiB1c2VySWQgfSB9KTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGJsb2NrY2hhaW4gY3JlZGVudGlhbHMgc2hvdWxkIGJlIHBlcm1hbmVudGx5IGRlbGV0ZWRcclxuICAgICAgLy8gVGhpcyBkZXBlbmRzIG9uIHlvdXIgcmVndWxhdG9yeSByZXF1aXJlbWVudHNcclxuICAgICAgY29uc3Qgd2FsbGV0SW5mbyA9IGF3YWl0IHRoaXMud2FsbGV0SW5mb1JlcG9zaXRvcnkuZmluZE9uZSh7XHJcbiAgICAgICAgd2hlcmU6IHsgdXNlcjogeyBpZDogdXNlcklkIH0gfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAod2FsbGV0SW5mbyAmJiB0aGlzLnNob3VsZFB1cmdlQmxvY2tjaGFpbkRhdGEod2FsbGV0SW5mbykpIHtcclxuICAgICAgICBhd2FpdCBxdWVyeVJ1bm5lci5tYW5hZ2VyLmRlbGV0ZShXYWxsZXRJbmZvLCB3YWxsZXRJbmZvLmlkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluYWxseSBoYXJkIGRlbGV0ZSB0aGUgdXNlclxyXG4gICAgICBhd2FpdCBxdWVyeVJ1bm5lci5tYW5hZ2VyLmRlbGV0ZShVc2VyLCB1c2VySWQpO1xyXG5cclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIuY29tbWl0VHJhbnNhY3Rpb24oKTtcclxuXHJcbiAgICAgIC8vIExvZyB0aGUgcGVybWFuZW50IGRlbGV0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMuYXVkaXRMb2dTZXJ2aWNlLmNyZWF0ZUxvZyh7XHJcbiAgICAgICAgYWN0aW9uOiAnQUNDT1VOVF9QVVJHRUQnLFxyXG4gICAgICAgIGVudGl0eVR5cGU6ICdVU0VSJyxcclxuICAgICAgICBlbnRpdHlJZDogdXNlcklkLFxyXG4gICAgICAgIHBlcmZvcm1lZEJ5OiAnU1lTVEVNJyxcclxuICAgICAgICBkZXRhaWxzOiB7XHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgVXNlciBkYXRhIGZvciAke3VzZXJJZH0gaGFzIGJlZW4gcGVybWFuZW50bHkgcHVyZ2VkYCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBhd2FpdCBxdWVyeVJ1bm5lci5yb2xsYmFja1RyYW5zYWN0aW9uKCk7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcHVyZ2UgdXNlciBkYXRhIGZvciAke3VzZXJJZH1gLCBlcnJvci5zdGFjayk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgYXdhaXQgcXVlcnlSdW5uZXIucmVsZWFzZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGlmIGJsb2NrY2hhaW4gZGF0YSBzaG91bGQgYmUgcHVyZ2VkIGJhc2VkIG9uIHJlZ3VsYXRpb25zXHJcbiAgICogQHBhcmFtIHdhbGxldEluZm8gV2FsbGV0IGluZm9ybWF0aW9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzaG91bGRQdXJnZUJsb2NrY2hhaW5EYXRhKHdhbGxldEluZm86IFdhbGxldEluZm8pOiBib29sZWFuIHtcclxuICAgIC8vIFRoaXMgbG9naWMgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJhc2VkIG9uIHlvdXIgc3BlY2lmaWMgcmVndWxhdG9yeSByZXF1aXJlbWVudHNcclxuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgbWlnaHQgbmVlZCB0byBrZWVwIHNvbWUgZGF0YSBmb3IgdGF4IHB1cnBvc2VzXHJcbiAgICAvLyBHRFBSIGFsbG93cyBrZWVwaW5nIGRhdGEgbmVlZGVkIGZvciBsZWdhbCBvYmxpZ2F0aW9uc1xyXG5cclxuICAgIC8vIEZvciBkZW1vbnN0cmF0aW9uLCB3ZSdyZSByZXR1cm5pbmcgZmFsc2UgdG8gcHJlc2VydmUgYmxvY2tjaGFpbiBkYXRhXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXR5IG1ldGhvZCB0byBmaW5kIGEgdXNlciBvciB0aHJvdyBleGNlcHRpb25cclxuICAgKiBAcGFyYW0gdXNlcklkIFVzZXIgSUQgdG8gZmluZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZmluZFVzZXJPckZhaWwodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXI+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRPbmUoe1xyXG4gICAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKGBVc2VyIHdpdGggSUQgJHt1c2VySWR9IG5vdCBmb3VuZGApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1c2VyO1xyXG4gIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=