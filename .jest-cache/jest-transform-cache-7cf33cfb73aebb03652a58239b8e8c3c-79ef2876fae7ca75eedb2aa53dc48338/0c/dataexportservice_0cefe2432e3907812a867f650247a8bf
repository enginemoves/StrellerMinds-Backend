e21ee460e861541313630ddddd8a45fd
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataExportService = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const data_processing_log_entity_1 = require("./entities/data-processing-log.entity");
const data_export_dto_1 = require("./dto/data-export.dto");
let DataExportService = class DataExportService {
    constructor(logRepository) {
        this.logRepository = logRepository;
    }
    async exportUserData(userId, request, ipAddress, userAgent) {
        // Log the export request
        await this.logDataProcessing(userId, data_processing_log_entity_1.ProcessingActivity.DATA_EXPORT, 'User data export requested', {
            dataTypes: request.dataTypes,
            format: request.format,
            reason: request.reason,
        }, ipAddress, userAgent);
        // Collect user data from various sources
        const userData = await this.collectUserData(userId, request.dataTypes);
        // Format the data based on requested format
        const formattedData = await this.formatExportData(userData, request.format);
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `user_data_export_${userId}_${timestamp}.${request.format}`;
        return {
            data: formattedData,
            filename,
        };
    }
    async collectUserData(userId, dataTypes) {
        const userData = {
            userId,
            exportDate: new Date().toISOString(),
            profile: {},
            preferences: {},
            consents: {},
            activityLogs: {},
        };
        // Collect profile data (implement based on your user model)
        if (!dataTypes || dataTypes.includes('profile')) {
            userData.profile = await this.getUserProfile(userId);
        }
        // Collect preferences
        if (!dataTypes || dataTypes.includes('preferences')) {
            userData.preferences = await this.getUserPreferences(userId);
        }
        // Collect consent records
        if (!dataTypes || dataTypes.includes('consents')) {
            userData.consents = await this.getUserConsents(userId);
        }
        // Collect activity logs
        if (!dataTypes || dataTypes.includes('activity')) {
            userData.activityLogs = await this.getUserActivityLogs(userId);
        }
        return userData;
    }
    async formatExportData(data, format) {
        switch (format) {
            case data_export_dto_1.ExportFormat.JSON:
                return JSON.stringify(data, null, 2);
            case data_export_dto_1.ExportFormat.CSV:
                return this.convertToCSV(data);
            case data_export_dto_1.ExportFormat.XML:
                return this.convertToXML(data);
            default:
                return data;
        }
    }
    convertToCSV(data) {
        // Implement CSV conversion logic
        const flattenedData = this.flattenObject(data);
        const headers = Object.keys(flattenedData).join(',');
        const values = Object.values(flattenedData).join(',');
        return `${headers}\n${values}`;
    }
    convertToXML(data) {
        // Implement XML conversion logic
        return `<?xml version="1.0" encoding="UTF-8"?>\n<userdata>${JSON.stringify(data)}</userdata>`;
    }
    flattenObject(obj, prefix = '') {
        const flattened = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const newKey = prefix ? `${prefix}.${key}` : key;
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    Object.assign(flattened, this.flattenObject(obj[key], newKey));
                }
                else {
                    flattened[newKey] = obj[key];
                }
            }
        }
        return flattened;
    }
    async getUserProfile(userId) {
        // Implement based on your User entity
        return { message: 'Implement getUserProfile method' };
    }
    async getUserPreferences(userId) {
        // Implement based on your preferences system
        return { message: 'Implement getUserPreferences method' };
    }
    async getUserConsents(userId) {
        // Implement to get user consents
        return { message: 'Implement getUserConsents method' };
    }
    async getUserActivityLogs(userId) {
        return this.logRepository.find({
            where: { userId },
            order: { createdAt: 'DESC' },
            take: 1000, // Limit to recent activity
        });
    }
    async logDataProcessing(userId, activity, description, metadata, ipAddress, userAgent) {
        const log = this.logRepository.create({
            userId,
            activity,
            description,
            metadata,
            ipAddress,
            userAgent,
        });
        await this.logRepository.save(log);
    }
};
exports.DataExportService = DataExportService;
exports.DataExportService = DataExportService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(data_processing_log_entity_1.DataProcessingLog)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], DataExportService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxvam9zZXBoXFxEb2N1bWVudHNcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFxnZHByXFxkYXRhLWV4cG9ydC5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBc0Q7QUFDdEQsMkNBQTRDO0FBQzVDLDZDQUFtRDtBQUNuRCxxQ0FBcUM7QUFDckMsc0ZBRytDO0FBQy9DLDJEQUEyRTtBQUdwRSxJQUFNLGlCQUFpQixHQUF2QixNQUFNLGlCQUFpQjtJQUM1QixZQUVVLGFBQTRDO1FBQTVDLGtCQUFhLEdBQWIsYUFBYSxDQUErQjtJQUNuRCxDQUFDO0lBRUosS0FBSyxDQUFDLGNBQWMsQ0FDbEIsTUFBYyxFQUNkLE9BQTZCLEVBQzdCLFNBQWlCLEVBQ2pCLFNBQWlCO1FBRWpCLHlCQUF5QjtRQUN6QixNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FDMUIsTUFBTSxFQUNOLCtDQUFrQixDQUFDLFdBQVcsRUFDOUIsNEJBQTRCLEVBQzVCO1lBQ0UsU0FBUyxFQUFFLE9BQU8sQ0FBQyxTQUFTO1lBQzVCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtZQUN0QixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07U0FDdkIsRUFDRCxTQUFTLEVBQ1QsU0FBUyxDQUNWLENBQUM7UUFFRix5Q0FBeUM7UUFDekMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFdkUsNENBQTRDO1FBQzVDLE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFNUUsTUFBTSxTQUFTLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekQsTUFBTSxRQUFRLEdBQUcsb0JBQW9CLE1BQU0s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RUFBRSxFQUFFLE1BQU0sRUFBRTtZQUNqQixLQUFLLEVBQUUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFO1lBQzVCLElBQUksRUFBRSxJQUFJLEVBQUUsMkJBQTJCO1NBQ3hDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxLQUFLLENBQUMsaUJBQWlCLENBQzdCLE1BQWMsRUFDZCxRQUE0QixFQUM1QixXQUFtQixFQUNuQixRQUFhLEVBQ2IsU0FBaUIsRUFDakIsU0FBaUI7UUFFakIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7WUFDcEMsTUFBTTtZQUNOLFFBQVE7WUFDUixXQUFXO1lBQ1gsUUFBUTtZQUNSLFNBQVM7WUFDVCxTQUFTO1NBQ1YsQ0FBQyxDQUFDO1FBRUgsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0YsQ0FBQTtBQW5LWSw4Q0FBaUI7NEJBQWpCLGlCQUFpQjtJQUQ3QixJQUFBLG1CQUFVLEdBQUU7SUFHUixXQUFBLElBQUEsMEJBQWdCLEVBQUMsOENBQWlCLENBQUMsQ0FBQTt5REFDYixvQkFBVSxvQkFBVixvQkFBVTtHQUh4QixpQkFBaUIsQ0FtSzdCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcb2pvc2VwaFxcRG9jdW1lbnRzXFxTdHJlbGxlck1pbmRzLUJhY2tlbmRcXHNyY1xcZ2RwclxcZGF0YS1leHBvcnQuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcclxuaW1wb3J0IHsgSW5qZWN0UmVwb3NpdG9yeSB9IGZyb20gJ0BuZXN0anMvdHlwZW9ybSc7XHJcbmltcG9ydCB7IFJlcG9zaXRvcnkgfSBmcm9tICd0eXBlb3JtJztcclxuaW1wb3J0IHtcclxuICBEYXRhUHJvY2Vzc2luZ0xvZyxcclxuICBQcm9jZXNzaW5nQWN0aXZpdHksXHJcbn0gZnJvbSAnLi9lbnRpdGllcy9kYXRhLXByb2Nlc3NpbmctbG9nLmVudGl0eSc7XHJcbmltcG9ydCB7IERhdGFFeHBvcnRSZXF1ZXN0RHRvLCBFeHBvcnRGb3JtYXQgfSBmcm9tICcuL2R0by9kYXRhLWV4cG9ydC5kdG8nO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRGF0YUV4cG9ydFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdFJlcG9zaXRvcnkoRGF0YVByb2Nlc3NpbmdMb2cpXHJcbiAgICBwcml2YXRlIGxvZ1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8RGF0YVByb2Nlc3NpbmdMb2c+LFxyXG4gICkge31cclxuXHJcbiAgYXN5bmMgZXhwb3J0VXNlckRhdGEoXHJcbiAgICB1c2VySWQ6IHN0cmluZyxcclxuICAgIHJlcXVlc3Q6IERhdGFFeHBvcnRSZXF1ZXN0RHRvLFxyXG4gICAgaXBBZGRyZXNzOiBzdHJpbmcsXHJcbiAgICB1c2VyQWdlbnQ6IHN0cmluZyxcclxuICApOiBQcm9taXNlPHsgZGF0YTogYW55OyBmaWxlbmFtZTogc3RyaW5nIH0+IHtcclxuICAgIC8vIExvZyB0aGUgZXhwb3J0IHJlcXVlc3RcclxuICAgIGF3YWl0IHRoaXMubG9nRGF0YVByb2Nlc3NpbmcoXHJcbiAgICAgIHVzZXJJZCxcclxuICAgICAgUHJvY2Vzc2luZ0FjdGl2aXR5LkRBVEFfRVhQT1JULFxyXG4gICAgICAnVXNlciBkYXRhIGV4cG9ydCByZXF1ZXN0ZWQnLFxyXG4gICAgICB7XHJcbiAgICAgICAgZGF0YVR5cGVzOiByZXF1ZXN0LmRhdGFUeXBlcyxcclxuICAgICAgICBmb3JtYXQ6IHJlcXVlc3QuZm9ybWF0LFxyXG4gICAgICAgIHJlYXNvbjogcmVxdWVzdC5yZWFzb24sXHJcbiAgICAgIH0sXHJcbiAgICAgIGlwQWRkcmVzcyxcclxuICAgICAgdXNlckFnZW50LFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDb2xsZWN0IHVzZXIgZGF0YSBmcm9tIHZhcmlvdXMgc291cmNlc1xyXG4gICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCB0aGlzLmNvbGxlY3RVc2VyRGF0YSh1c2VySWQsIHJlcXVlc3QuZGF0YVR5cGVzKTtcclxuXHJcbiAgICAvLyBGb3JtYXQgdGhlIGRhdGEgYmFzZWQgb24gcmVxdWVzdGVkIGZvcm1hdFxyXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IGF3YWl0IHRoaXMuZm9ybWF0RXhwb3J0RGF0YSh1c2VyRGF0YSwgcmVxdWVzdC5mb3JtYXQpO1xyXG5cclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG4gICAgY29uc3QgZmlsZW5hbWUgPSBgdXNlcl9kYXRhX2V4cG9ydF8ke3VzZXJJZH1fJHt0aW1lc3RhbXB9LiR7cmVxdWVzdC5mb3JtYXR9YDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBmb3JtYXR0ZWREYXRhLFxyXG4gICAgICBmaWxlbmFtZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNvbGxlY3RVc2VyRGF0YShcclxuICAgIHVzZXJJZDogc3RyaW5nLFxyXG4gICAgZGF0YVR5cGVzPzogc3RyaW5nW10sXHJcbiAgKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IHVzZXJEYXRhOiBhbnkgPSB7XHJcbiAgICAgIHVzZXJJZCxcclxuICAgICAgZXhwb3J0RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBwcm9maWxlOiB7fSxcclxuICAgICAgcHJlZmVyZW5jZXM6IHt9LFxyXG4gICAgICBjb25zZW50czoge30sXHJcbiAgICAgIGFjdGl2aXR5TG9nczoge30sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENvbGxlY3QgcHJvZmlsZSBkYXRhIChpbXBsZW1lbnQgYmFzZWQgb24geW91ciB1c2VyIG1vZGVsKVxyXG4gICAgaWYgKCFkYXRhVHlwZXMgfHwgZGF0YVR5cGVzLmluY2x1ZGVzKCdwcm9maWxlJykpIHtcclxuICAgICAgdXNlckRhdGEucHJvZmlsZSA9IGF3YWl0IHRoaXMuZ2V0VXNlclByb2ZpbGUodXNlcklkKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2xsZWN0IHByZWZlcmVuY2VzXHJcbiAgICBpZiAoIWRhdGFUeXBlcyB8fCBkYXRhVHlwZXMuaW5jbHVkZXMoJ3ByZWZlcmVuY2VzJykpIHtcclxuICAgICAgdXNlckRhdGEucHJlZmVyZW5jZXMgPSBhd2FpdCB0aGlzLmdldFVzZXJQcmVmZXJlbmNlcyh1c2VySWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbGxlY3QgY29uc2VudCByZWNvcmRzXHJcbiAgICBpZiAoIWRhdGFUeXBlcyB8fCBkYXRhVHlwZXMuaW5jbHVkZXMoJ2NvbnNlbnRzJykpIHtcclxuICAgICAgdXNlckRhdGEuY29uc2VudHMgPSBhd2FpdCB0aGlzLmdldFVzZXJDb25zZW50cyh1c2VySWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbGxlY3QgYWN0aXZpdHkgbG9nc1xyXG4gICAgaWYgKCFkYXRhVHlwZXMgfHwgZGF0YVR5cGVzLmluY2x1ZGVzKCdhY3Rpdml0eScpKSB7XHJcbiAgICAgIHVzZXJEYXRhLmFjdGl2aXR5TG9ncyA9IGF3YWl0IHRoaXMuZ2V0VXNlckFjdGl2aXR5TG9ncyh1c2VySWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1c2VyRGF0YTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZm9ybWF0RXhwb3J0RGF0YShcclxuICAgIGRhdGE6IGFueSxcclxuICAgIGZvcm1hdDogRXhwb3J0Rm9ybWF0LFxyXG4gICk6IFByb21pc2U8c3RyaW5nIHwgYW55PiB7XHJcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICBjYXNlIEV4cG9ydEZvcm1hdC5KU09OOlxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcclxuICAgICAgY2FzZSBFeHBvcnRGb3JtYXQuQ1NWOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUb0NTVihkYXRhKTtcclxuICAgICAgY2FzZSBFeHBvcnRGb3JtYXQuWE1MOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUb1hNTChkYXRhKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY29udmVydFRvQ1NWKGRhdGE6IGFueSk6IHN0cmluZyB7XHJcbiAgICAvLyBJbXBsZW1lbnQgQ1NWIGNvbnZlcnNpb24gbG9naWNcclxuICAgIGNvbnN0IGZsYXR0ZW5lZERhdGEgPSB0aGlzLmZsYXR0ZW5PYmplY3QoZGF0YSk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmtleXMoZmxhdHRlbmVkRGF0YSkuam9pbignLCcpO1xyXG4gICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhmbGF0dGVuZWREYXRhKS5qb2luKCcsJyk7XHJcbiAgICByZXR1cm4gYCR7aGVhZGVyc31cXG4ke3ZhbHVlc31gO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjb252ZXJ0VG9YTUwoZGF0YTogYW55KTogc3RyaW5nIHtcclxuICAgIC8vIEltcGxlbWVudCBYTUwgY29udmVyc2lvbiBsb2dpY1xyXG4gICAgcmV0dXJuIGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG48dXNlcmRhdGE+JHtKU09OLnN0cmluZ2lmeShkYXRhKX08L3VzZXJkYXRhPmA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZsYXR0ZW5PYmplY3Qob2JqOiBhbnksIHByZWZpeCA9ICcnKTogYW55IHtcclxuICAgIGNvbnN0IGZsYXR0ZW5lZDogYW55ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgY29uc3QgbmV3S2V5ID0gcHJlZml4ID8gYCR7cHJlZml4fS4ke2tleX1gIDoga2V5O1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnICYmIG9ialtrZXldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGZsYXR0ZW5lZCwgdGhpcy5mbGF0dGVuT2JqZWN0KG9ialtrZXldLCBuZXdLZXkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmxhdHRlbmVkW25ld0tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmbGF0dGVuZWQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldFVzZXJQcm9maWxlKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIC8vIEltcGxlbWVudCBiYXNlZCBvbiB5b3VyIFVzZXIgZW50aXR5XHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiAnSW1wbGVtZW50IGdldFVzZXJQcm9maWxlIG1ldGhvZCcgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0VXNlclByZWZlcmVuY2VzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIC8vIEltcGxlbWVudCBiYXNlZCBvbiB5b3VyIHByZWZlcmVuY2VzIHN5c3RlbVxyXG4gICAgcmV0dXJuIHsgbWVzc2FnZTogJ0ltcGxlbWVudCBnZXRVc2VyUHJlZmVyZW5jZXMgbWV0aG9kJyB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRVc2VyQ29uc2VudHModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgLy8gSW1wbGVtZW50IHRvIGdldCB1c2VyIGNvbnNlbnRzXHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiAnSW1wbGVtZW50IGdldFVzZXJDb25zZW50cyBtZXRob2QnIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldFVzZXJBY3Rpdml0eUxvZ3ModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgcmV0dXJuIHRoaXMubG9nUmVwb3NpdG9yeS5maW5kKHtcclxuICAgICAgd2hlcmU6IHsgdXNlcklkIH0sXHJcbiAgICAgIG9yZGVyOiB7IGNyZWF0ZWRBdDogJ0RFU0MnIH0sXHJcbiAgICAgIHRha2U6IDEwMDAsIC8vIExpbWl0IHRvIHJlY2VudCBhY3Rpdml0eVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGxvZ0RhdGFQcm9jZXNzaW5nKFxyXG4gICAgdXNlcklkOiBzdHJpbmcsXHJcbiAgICBhY3Rpdml0eTogUHJvY2Vzc2luZ0FjdGl2aXR5LFxyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcclxuICAgIG1ldGFkYXRhOiBhbnksXHJcbiAgICBpcEFkZHJlc3M6IHN0cmluZyxcclxuICAgIHVzZXJBZ2VudDogc3RyaW5nLFxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgbG9nID0gdGhpcy5sb2dSZXBvc2l0b3J5LmNyZWF0ZSh7XHJcbiAgICAgIHVzZXJJZCxcclxuICAgICAgYWN0aXZpdHksXHJcbiAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICBtZXRhZGF0YSxcclxuICAgICAgaXBBZGRyZXNzLFxyXG4gICAgICB1c2VyQWdlbnQsXHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmxvZ1JlcG9zaXRvcnkuc2F2ZShsb2cpO1xyXG4gIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=