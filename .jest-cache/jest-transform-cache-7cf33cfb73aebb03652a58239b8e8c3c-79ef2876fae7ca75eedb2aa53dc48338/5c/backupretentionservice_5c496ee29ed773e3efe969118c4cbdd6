42e124b1de11bcd86d2cc76812a2f3b7
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var BackupRetentionService_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackupRetentionService = void 0;
/* eslint-disable prettier/prettier */
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const fs = __importStar(require("fs/promises"));
const path = __importStar(require("path"));
let BackupRetentionService = BackupRetentionService_1 = class BackupRetentionService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(BackupRetentionService_1.name);
        this.backupDir = this.configService.get('BACKUP_DIR', './backups');
        this.retentionDays = this.configService.get('BACKUP_RETENTION_DAYS', 30);
        this.monthlyRetentionMonths = this.configService.get('BACKUP_MONTHLY_RETENTION_MONTHS', 12);
    }
    async cleanupOldBackups() {
        try {
            const files = await fs.readdir(this.backupDir);
            const backupFiles = files.filter((file) => file.endsWith('.sql') || file.endsWith('.tar.gz'));
            const now = new Date();
            const cutoffDate = new Date(now.getTime() - this.retentionDays * 24 * 60 * 60 * 1000);
            const monthlyCutoffDate = new Date(now.getTime() - this.monthlyRetentionMonths * 30 * 24 * 60 * 60 * 1000);
            let deletedCount = 0;
            let preservedCount = 0;
            for (const file of backupFiles) {
                const filePath = path.join(this.backupDir, file);
                const stats = await fs.stat(filePath);
                const fileDate = stats.birthtime;
                // Keep monthly backups (first backup of each month) for longer
                const isMonthlyBackup = this.isFirstBackupOfMonth(file, backupFiles);
                if (isMonthlyBackup && fileDate > monthlyCutoffDate) {
                    preservedCount++;
                    continue;
                }
                if (fileDate < cutoffDate) {
                    await fs.unlink(filePath);
                    this.logger.log(`Deleted old backup: ${file}`);
                    deletedCount++;
                }
                else {
                    preservedCount++;
                }
            }
            this.logger.log(`Backup cleanup completed: ${deletedCount} deleted, ${preservedCount} preserved`);
        }
        catch (error) {
            this.logger.error(`Backup cleanup failed: ${error.message}`, error.stack);
        }
    }
    isFirstBackupOfMonth(filename, allFiles) {
        // Extract date from filename (assuming format: db-backup-YYYY-MM-DDTHH-MM-SS.sql)
        const dateMatch = filename.match(/(\d{4}-\d{2}-\d{2})/);
        if (!dateMatch)
            return false;
        const fileDate = dateMatch[1];
        const yearMonth = fileDate.substring(0, 7); // YYYY-MM
        // Check if this is the first backup file for this month
        const monthFiles = allFiles.filter((f) => f.includes(yearMonth)).sort();
        return monthFiles[0] === filename;
    }
};
exports.BackupRetentionService = BackupRetentionService;
exports.BackupRetentionService = BackupRetentionService = BackupRetentionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], BackupRetentionService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxvam9zZXBoXFxEb2N1bWVudHNcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFxiYWNrdXBcXGJhY2t1cC1yZXRlbnRpb24uc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNDQUFzQztBQUN0QywyQ0FBb0Q7QUFDcEQsMkNBQStDO0FBQy9DLGdEQUFrQztBQUNsQywyQ0FBNkI7QUFHdEIsSUFBTSxzQkFBc0IsOEJBQTVCLE1BQU0sc0JBQXNCO0lBTWpDLFlBQTZCLGFBQTRCO1FBQTVCLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBTHhDLFdBQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyx3QkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQU1oRSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFTLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUN6Qyx1QkFBdUIsRUFDdkIsRUFBRSxDQUNILENBQUM7UUFDRixJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQ2xELGlDQUFpQyxFQUNqQyxFQUFFLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQztZQUNILE1BQU0sS0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDL0MsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FDOUIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FDNUQsQ0FBQztZQUVGLE1BQU0sR0FBRyxHQUFH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cnNcXG9qb3NlcGhcXERvY3VtZW50c1xcU3RyZWxsZXJNaW5kcy1CYWNrZW5kXFxzcmNcXGJhY2t1cFxcYmFja3VwLXJldGVudGlvbi5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyICovXHJcbmltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcclxuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMvcHJvbWlzZXMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmFja3VwUmV0ZW50aW9uU2VydmljZSB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKEJhY2t1cFJldGVudGlvblNlcnZpY2UubmFtZSk7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBiYWNrdXBEaXI6IHN0cmluZztcclxuICBwcml2YXRlIHJlYWRvbmx5IHJldGVudGlvbkRheXM6IG51bWJlcjtcclxuICBwcml2YXRlIHJlYWRvbmx5IG1vbnRobHlSZXRlbnRpb25Nb250aHM6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb25maWdTZXJ2aWNlOiBDb25maWdTZXJ2aWNlKSB7XHJcbiAgICB0aGlzLmJhY2t1cERpciA9IHRoaXMuY29uZmlnU2VydmljZS5nZXQ8c3RyaW5nPignQkFDS1VQX0RJUicsICcuL2JhY2t1cHMnKTtcclxuICAgIHRoaXMucmV0ZW50aW9uRGF5cyA9IHRoaXMuY29uZmlnU2VydmljZS5nZXQ8bnVtYmVyPihcclxuICAgICAgJ0JBQ0tVUF9SRVRFTlRJT05fREFZUycsXHJcbiAgICAgIDMwLFxyXG4gICAgKTtcclxuICAgIHRoaXMubW9udGhseVJldGVudGlvbk1vbnRocyA9IHRoaXMuY29uZmlnU2VydmljZS5nZXQ8bnVtYmVyPihcclxuICAgICAgJ0JBQ0tVUF9NT05USExZX1JFVEVOVElPTl9NT05USFMnLFxyXG4gICAgICAxMixcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjbGVhbnVwT2xkQmFja3VwcygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcih0aGlzLmJhY2t1cERpcik7XHJcbiAgICAgIGNvbnN0IGJhY2t1cEZpbGVzID0gZmlsZXMuZmlsdGVyKFxyXG4gICAgICAgIChmaWxlKSA9PiBmaWxlLmVuZHNXaXRoKCcuc3FsJykgfHwgZmlsZS5lbmRzV2l0aCgnLnRhci5neicpLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgIG5vdy5nZXRUaW1lKCkgLSB0aGlzLnJldGVudGlvbkRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBtb250aGx5Q3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgIG5vdy5nZXRUaW1lKCkgLSB0aGlzLm1vbnRobHlSZXRlbnRpb25Nb250aHMgKiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBsZXQgZGVsZXRlZENvdW50ID0gMDtcclxuICAgICAgbGV0IHByZXNlcnZlZENvdW50ID0gMDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBiYWNrdXBGaWxlcykge1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHRoaXMuYmFja3VwRGlyLCBmaWxlKTtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVEYXRlID0gc3RhdHMuYmlydGh0aW1lO1xyXG5cclxuICAgICAgICAvLyBLZWVwIG1vbnRobHkgYmFja3VwcyAoZmlyc3QgYmFja3VwIG9mIGVhY2ggbW9udGgpIGZvciBsb25nZXJcclxuICAgICAgICBjb25zdCBpc01vbnRobHlCYWNrdXAgPSB0aGlzLmlzRmlyc3RCYWNrdXBPZk1vbnRoKGZpbGUsIGJhY2t1cEZpbGVzKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9udGhseUJhY2t1cCAmJiBmaWxlRGF0ZSA+IG1vbnRobHlDdXRvZmZEYXRlKSB7XHJcbiAgICAgICAgICBwcmVzZXJ2ZWRDb3VudCsrO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlsZURhdGUgPCBjdXRvZmZEYXRlKSB7XHJcbiAgICAgICAgICBhd2FpdCBmcy51bmxpbmsoZmlsZVBhdGgpO1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBEZWxldGVkIG9sZCBiYWNrdXA6ICR7ZmlsZX1gKTtcclxuICAgICAgICAgIGRlbGV0ZWRDb3VudCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcmVzZXJ2ZWRDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sb2dnZXIubG9nKFxyXG4gICAgICAgIGBCYWNrdXAgY2xlYW51cCBjb21wbGV0ZWQ6ICR7ZGVsZXRlZENvdW50fSBkZWxldGVkLCAke3ByZXNlcnZlZENvdW50fSBwcmVzZXJ2ZWRgLFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEJhY2t1cCBjbGVhbnVwIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yLnN0YWNrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNGaXJzdEJhY2t1cE9mTW9udGgoZmlsZW5hbWU6IHN0cmluZywgYWxsRmlsZXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XHJcbiAgICAvLyBFeHRyYWN0IGRhdGUgZnJvbSBmaWxlbmFtZSAoYXNzdW1pbmcgZm9ybWF0OiBkYi1iYWNrdXAtWVlZWS1NTS1ERFRISC1NTS1TUy5zcWwpXHJcbiAgICBjb25zdCBkYXRlTWF0Y2ggPSBmaWxlbmFtZS5tYXRjaCgvKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pO1xyXG4gICAgaWYgKCFkYXRlTWF0Y2gpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBmaWxlRGF0ZSA9IGRhdGVNYXRjaFsxXTtcclxuICAgIGNvbnN0IHllYXJNb250aCA9IGZpbGVEYXRlLnN1YnN0cmluZygwLCA3KTsgLy8gWVlZWS1NTVxyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGJhY2t1cCBmaWxlIGZvciB0aGlzIG1vbnRoXHJcbiAgICBjb25zdCBtb250aEZpbGVzID0gYWxsRmlsZXMuZmlsdGVyKChmKSA9PiBmLmluY2x1ZGVzKHllYXJNb250aCkpLnNvcnQoKTtcclxuXHJcbiAgICByZXR1cm4gbW9udGhGaWxlc1swXSA9PT0gZmlsZW5hbWU7XHJcbiAgfVxyXG59XHJcbiJdLCJ2ZXJzaW9uIjozfQ==