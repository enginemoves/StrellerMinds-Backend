9ab6fff1a72431c5d1546dc07ad05f4b
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DataCollectionService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataCollectionService = void 0;
const common_1 = require("@nestjs/common");
let DataCollectionService = DataCollectionService_1 = class DataCollectionService {
    constructor(analyticsEventRepository, dataCollectionQueue, realTimeAnalyticsService) {
        this.analyticsEventRepository = analyticsEventRepository;
        this.dataCollectionQueue = dataCollectionQueue;
        this.realTimeAnalyticsService = realTimeAnalyticsService;
        this.logger = new common_1.Logger(DataCollectionService_1.name);
    }
    async trackEvent(eventData) {
        try {
            // Add to queue for async processing
            await this.dataCollectionQueue.add("process-event", {
                ...eventData,
                timestamp: new Date(),
            });
            // Send to real-time analytics
            await this.realTimeAnalyticsService.processRealTimeEvent(eventData);
            this.logger.log(`Event tracked: ${eventData.eventName}`);
        }
        catch (error) {
            this.logger.error(`Failed to track event: ${error.message}`, error.stack);
            throw error;
        }
    }
    async batchTrackEvents(events) {
        try {
            const jobs = events.map((eventData) => ({
                name: "process-event",
                data: {
                    ...eventData,
                    timestamp: new Date(),
                },
            }));
            await this.dataCollectionQueue.addBulk(jobs);
            // Process real-time events
            await Promise.all(events.map((event) => this.realTimeAnalyticsService.processRealTimeEvent(event)));
            this.logger.log(`Batch tracked ${events.length} events`);
        }
        catch (error) {
            this.logger.error(`Failed to batch track events: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getEvents(filters) {
        const query = this.analyticsEventRepository.createQueryBuilder("event");
        if (filters.eventType) {
            query.andWhere("event.eventType = :eventType", {
                eventType: filters.eventType,
            });
        }
        if (filters.userId) {
            query.andWhere("event.userId = :userId", { userId: filters.userId });
        }
        if (filters.sessionId) {
            query.andWhere("event.sessionId = :sessionId", {
                sessionId: filters.sessionId,
            });
        }
        if (filters.startDate) {
            query.andWhere("event.timestamp >= :startDate", {
                startDate: filters.startDate,
            });
        }
        if (filters.endDate) {
            query.andWhere("event.timestamp <= :endDate", {
                endDate: filters.endDate,
            });
        }
        query.orderBy("event.timestamp", "DESC");
        if (filters.limit) {
            query.limit(filters.limit);
        }
        if (filters.offset) {
            query.offset(filters.offset);
        }
        const [events, total] = await query.getManyAndCount();
        return { events, total };
    }
};
exports.DataCollectionService = DataCollectionService;
exports.DataCollectionService = DataCollectionService = DataCollectionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [Object, Object, Object])
], DataCollectionService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxvam9zZXBoXFxEb2N1bWVudHNcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFxhbmFseXRpY1xcc2VydmljZXNcXGRhdGEtY29sbGVjdGlvbi5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBbUQ7QUFtQjVDLElBQU0scUJBQXFCLDZCQUEzQixNQUFNLHFCQUFxQjtJQUdoQyxZQUNtQix3QkFBb0QsRUFDcEQsbUJBQTBCLEVBQzFCLHdCQUFrRDtRQUZsRCw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTRCO1FBQ3BELHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBTztRQUMxQiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO1FBTHBELFdBQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyx1QkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQU03RCxDQUFDO0lBRUosS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFvQjtRQUNuQyxJQUFJLENBQUM7WUFDSCxvQ0FBb0M7WUFDcEMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRTtnQkFDbEQsR0FBRyxTQUFTO2dCQUNaLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTthQUN0QixDQUFDLENBQUE7WUFFRiw4QkFBOEI7WUFDOUIsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUE7WUFFbkUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFBO1FBQzFELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsMEJBQTBCLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDekUsTUFBTSxLQUFLLENBQUE7UUFDYixDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUss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O0FBdEdZLHNEQUFxQjtnQ0FBckIscUJBQXFCO0lBRGpDLElBQUEsbUJBQVUsR0FBRTs7R0FDQSxxQkFBcUIsQ0FzR2pDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcb2pvc2VwaFxcRG9jdW1lbnRzXFxTdHJlbGxlck1pbmRzLUJhY2tlbmRcXHNyY1xcYW5hbHl0aWNcXHNlcnZpY2VzXFxkYXRhLWNvbGxlY3Rpb24uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIgfSBmcm9tIFwiQG5lc3Rqcy9jb21tb25cIlxyXG5pbXBvcnQgdHlwZSB7IFJlcG9zaXRvcnkgfSBmcm9tIFwidHlwZW9ybVwiXHJcbmltcG9ydCB0eXBlIHsgUXVldWUgfSBmcm9tIFwiYnVsbFwiXHJcblxyXG5pbXBvcnQgdHlwZSB7IEFuYWx5dGljc0V2ZW50LCBFdmVudFR5cGUgfSBmcm9tIFwiLi4vZW50aXRpZXMvYW5hbHl0aWNzLWV2ZW50LmVudGl0eVwiXHJcbmltcG9ydCB0eXBlIHsgUmVhbFRpbWVBbmFseXRpY3NTZXJ2aWNlIH0gZnJvbSBcIi4vcmVhbC10aW1lLWFuYWx5dGljcy5zZXJ2aWNlXCJcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnREYXRhIHtcclxuICBldmVudFR5cGU6IEV2ZW50VHlwZVxyXG4gIGV2ZW50TmFtZTogc3RyaW5nXHJcbiAgdXNlcklkPzogc3RyaW5nXHJcbiAgc2Vzc2lvbklkPzogc3RyaW5nXHJcbiAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxyXG4gIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgc291cmNlPzogc3RyaW5nXHJcbiAgY2hhbm5lbD86IHN0cmluZ1xyXG59XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBEYXRhQ29sbGVjdGlvblNlcnZpY2Uge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihEYXRhQ29sbGVjdGlvblNlcnZpY2UubmFtZSlcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFuYWx5dGljc0V2ZW50UmVwb3NpdG9yeTogUmVwb3NpdG9yeTxBbmFseXRpY3NFdmVudD4sXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhdGFDb2xsZWN0aW9uUXVldWU6IFF1ZXVlLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSByZWFsVGltZUFuYWx5dGljc1NlcnZpY2U6IFJlYWxUaW1lQW5hbHl0aWNzU2VydmljZSxcclxuICApIHt9XHJcblxyXG4gIGFzeW5jIHRyYWNrRXZlbnQoZXZlbnREYXRhOiBFdmVudERhdGEpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEFkZCB0byBxdWV1ZSBmb3IgYXN5bmMgcHJvY2Vzc2luZ1xyXG4gICAgICBhd2FpdCB0aGlzLmRhdGFDb2xsZWN0aW9uUXVldWUuYWRkKFwicHJvY2Vzcy1ldmVudFwiLCB7XHJcbiAgICAgICAgLi4uZXZlbnREYXRhLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIFNlbmQgdG8gcmVhbC10aW1lIGFuYWx5dGljc1xyXG4gICAgICBhd2FpdCB0aGlzLnJlYWxUaW1lQW5hbHl0aWNzU2VydmljZS5wcm9jZXNzUmVhbFRpbWVFdmVudChldmVudERhdGEpXHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5sb2coYEV2ZW50IHRyYWNrZWQ6ICR7ZXZlbnREYXRhLmV2ZW50TmFtZX1gKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byB0cmFjayBldmVudDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yLnN0YWNrKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYmF0Y2hUcmFja0V2ZW50cyhldmVudHM6IEV2ZW50RGF0YVtdKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBqb2JzID0gZXZlbnRzLm1hcCgoZXZlbnREYXRhKSA9PiAoe1xyXG4gICAgICAgIG5hbWU6IFwicHJvY2Vzcy1ldmVudFwiLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgIC4uLmV2ZW50RGF0YSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KSlcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMuZGF0YUNvbGxlY3Rpb25RdWV1ZS5hZGRCdWxrKGpvYnMpXHJcblxyXG4gICAgICAvLyBQcm9jZXNzIHJlYWwtdGltZSBldmVudHNcclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZXZlbnRzLm1hcCgoZXZlbnQpID0+IHRoaXMucmVhbFRpbWVBbmFseXRpY3NTZXJ2aWNlLnByb2Nlc3NSZWFsVGltZUV2ZW50KGV2ZW50KSkpXHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5sb2coYEJhdGNoIHRyYWNrZWQgJHtldmVudHMubGVuZ3RofSBldmVudHNgKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBiYXRjaCB0cmFjayBldmVudHM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvci5zdGFjaylcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEV2ZW50cyhmaWx0ZXJzOiB7XHJcbiAgICBldmVudFR5cGU/OiBFdmVudFR5cGVcclxuICAgIHVzZXJJZD86IHN0cmluZ1xyXG4gICAgc2Vzc2lvbklkPzogc3RyaW5nXHJcbiAgICBzdGFydERhdGU/OiBEYXRlXHJcbiAgICBlbmREYXRlPzogRGF0ZVxyXG4gICAgbGltaXQ/OiBudW1iZXJcclxuICAgIG9mZnNldD86IG51bWJlclxyXG4gIH0pOiBQcm9taXNlPHsgZXZlbnRzOiBBbmFseXRpY3NFdmVudFtdOyB0b3RhbDogbnVtYmVyIH0+IHtcclxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5hbmFseXRpY3NFdmVudFJlcG9zaXRvcnkuY3JlYXRlUXVlcnlCdWlsZGVyKFwiZXZlbnRcIilcclxuXHJcbiAgICBpZiAoZmlsdGVycy5ldmVudFR5cGUpIHtcclxuICAgICAgcXVlcnkuYW5kV2hlcmUoXCJldmVudC5ldmVudFR5cGUgPSA6ZXZlbnRUeXBlXCIsIHtcclxuICAgICAgICBldmVudFR5cGU6IGZpbHRlcnMuZXZlbnRUeXBlLFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChmaWx0ZXJzLnVzZXJJZCkge1xyXG4gICAgICBxdWVyeS5hbmRXaGVyZShcImV2ZW50LnVzZXJJZCA9IDp1c2VySWRcIiwgeyB1c2VySWQ6IGZpbHRlcnMudXNlcklkIH0pXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbHRlcnMuc2Vzc2lvbklkKSB7XHJcbiAgICAgIHF1ZXJ5LmFuZFdoZXJlKFwiZXZlbnQuc2Vzc2lvbklkID0gOnNlc3Npb25JZFwiLCB7XHJcbiAgICAgICAgc2Vzc2lvbklkOiBmaWx0ZXJzLnNlc3Npb25JZCxcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsdGVycy5zdGFydERhdGUpIHtcclxuICAgICAgcXVlcnkuYW5kV2hlcmUoXCJldmVudC50aW1lc3RhbXAgPj0gOnN0YXJ0RGF0ZVwiLCB7XHJcbiAgICAgICAgc3RhcnREYXRlOiBmaWx0ZXJzLnN0YXJ0RGF0ZSxcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsdGVycy5lbmREYXRlKSB7XHJcbiAgICAgIHF1ZXJ5LmFuZFdoZXJlKFwiZXZlbnQudGltZXN0YW1wIDw9IDplbmREYXRlXCIsIHtcclxuICAgICAgICBlbmREYXRlOiBmaWx0ZXJzLmVuZERhdGUsXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcXVlcnkub3JkZXJCeShcImV2ZW50LnRpbWVzdGFtcFwiLCBcIkRFU0NcIilcclxuXHJcbiAgICBpZiAoZmlsdGVycy5saW1pdCkge1xyXG4gICAgICBxdWVyeS5saW1pdChmaWx0ZXJzLmxpbWl0KVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChmaWx0ZXJzLm9mZnNldCkge1xyXG4gICAgICBxdWVyeS5vZmZzZXQoZmlsdGVycy5vZmZzZXQpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgW2V2ZW50cywgdG90YWxdID0gYXdhaXQgcXVlcnkuZ2V0TWFueUFuZENvdW50KClcclxuXHJcbiAgICByZXR1cm4geyBldmVudHMsIHRvdGFsIH1cclxuICB9XHJcbn1cclxuIl0sInZlcnNpb24iOjN9