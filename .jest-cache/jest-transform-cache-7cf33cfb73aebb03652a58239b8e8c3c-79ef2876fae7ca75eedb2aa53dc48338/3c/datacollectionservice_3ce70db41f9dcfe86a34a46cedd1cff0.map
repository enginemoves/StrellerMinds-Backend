{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\analytic\\services\\data-collection.service.ts","mappings":";;;;;;;;;;;;;AAAA,2CAAmD;AAmB5C,IAAM,qBAAqB,6BAA3B,MAAM,qBAAqB;IAGhC,YACmB,wBAAoD,EACpD,mBAA0B,EAC1B,wBAAkD;QAFlD,6BAAwB,GAAxB,wBAAwB,CAA4B;QACpD,wBAAmB,GAAnB,mBAAmB,CAAO;QAC1B,6BAAwB,GAAxB,wBAAwB,CAA0B;QALpD,WAAM,GAAG,IAAI,eAAM,CAAC,uBAAqB,CAAC,IAAI,CAAC,CAAA;IAM7D,CAAC;IAEJ,KAAK,CAAC,UAAU,CAAC,SAAoB;QACnC,IAAI,CAAC;YACH,oCAAoC;YACpC,MAAM,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,eAAe,EAAE;gBAClD,GAAG,SAAS;gBACZ,SAAS,EAAE,IAAI,IAAI,EAAE;aACtB,CAAC,CAAA;YAEF,8BAA8B;YAC9B,MAAM,IAAI,CAAC,wBAAwB,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAA;YAEnE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,SAAS,CAAC,SAAS,EAAE,CAAC,CAAA;QAC1D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,KAAK,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAA;YACzE,MAAM,KAAK,CAAA;QACb,CAAC;IACH,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,MAAmB;QACxC,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;gBACtC,IAAI,EAAE,eAAe;gBACrB,IAAI,EAAE;oBACJ,GAAG,SAAS;oBACZ,SAAS,EAAE,IAAI,IAAI,EAAE;iBACtB;aACF,CAAC,CAAC,CAAA;YAEH,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;YAE5C,2BAA2B;YAC3B,MAAM,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,wBAAwB,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;YAEnG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,iBAAiB,MAAM,CAAC,MAAM,SAAS,CAAC,CAAA;QAC1D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,iCAAiC,KAAK,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAA;YAChF,MAAM,KAAK,CAAA;QACb,CAAC;IACH,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,OAQf;QACC,MAAM,KAAK,GAAG,IAAI,CAAC,wBAAwB,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAA;QAEvE,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;YACtB,KAAK,CAAC,QAAQ,CAAC,8BAA8B,EAAE;gBAC7C,SAAS,EAAE,OAAO,CAAC,SAAS;aAC7B,CAAC,CAAA;QACJ,CAAC;QAED,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;YACnB,KAAK,CAAC,QAAQ,CAAC,wBAAwB,EAAE,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC,CAAA;QACtE,CAAC;QAED,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;YACtB,KAAK,CAAC,QAAQ,CAAC,8BAA8B,EAAE;gBAC7C,SAAS,EAAE,OAAO,CAAC,SAAS;aAC7B,CAAC,CAAA;QACJ,CAAC;QAED,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;YACtB,KAAK,CAAC,QAAQ,CAAC,+BAA+B,EAAE;gBAC9C,SAAS,EAAE,OAAO,CAAC,SAAS;aAC7B,CAAC,CAAA;QACJ,CAAC;QAED,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;YACpB,KAAK,CAAC,QAAQ,CAAC,6BAA6B,EAAE;gBAC5C,OAAO,EAAE,OAAO,CAAC,OAAO;aACzB,CAAC,CAAA;QACJ,CAAC;QAED,KAAK,CAAC,OAAO,CAAC,iBAAiB,EAAE,MAAM,CAAC,CAAA;QAExC,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YAClB,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;QAC5B,CAAC;QAED,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;YACnB,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;QAC9B,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM,KAAK,CAAC,eAAe,EAAE,CAAA;QAErD,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,CAAA;IAC1B,CAAC;CACF,CAAA;AAtGY,sDAAqB;gCAArB,qBAAqB;IADjC,IAAA,mBAAU,GAAE;;GACA,qBAAqB,CAsGjC","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\analytic\\services\\data-collection.service.ts"],"sourcesContent":["import { Injectable, Logger } from \"@nestjs/common\"\r\nimport type { Repository } from \"typeorm\"\r\nimport type { Queue } from \"bull\"\r\n\r\nimport type { AnalyticsEvent, EventType } from \"../entities/analytics-event.entity\"\r\nimport type { RealTimeAnalyticsService } from \"./real-time-analytics.service\"\r\n\r\nexport interface EventData {\r\n  eventType: EventType\r\n  eventName: string\r\n  userId?: string\r\n  sessionId?: string\r\n  properties: Record<string, any>\r\n  context?: Record<string, any>\r\n  source?: string\r\n  channel?: string\r\n}\r\n\r\n@Injectable()\r\nexport class DataCollectionService {\r\n  private readonly logger = new Logger(DataCollectionService.name)\r\n\r\n  constructor(\r\n    private readonly analyticsEventRepository: Repository<AnalyticsEvent>,\r\n    private readonly dataCollectionQueue: Queue,\r\n    private readonly realTimeAnalyticsService: RealTimeAnalyticsService,\r\n  ) {}\r\n\r\n  async trackEvent(eventData: EventData): Promise<void> {\r\n    try {\r\n      // Add to queue for async processing\r\n      await this.dataCollectionQueue.add(\"process-event\", {\r\n        ...eventData,\r\n        timestamp: new Date(),\r\n      })\r\n\r\n      // Send to real-time analytics\r\n      await this.realTimeAnalyticsService.processRealTimeEvent(eventData)\r\n\r\n      this.logger.log(`Event tracked: ${eventData.eventName}`)\r\n    } catch (error) {\r\n      this.logger.error(`Failed to track event: ${error.message}`, error.stack)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  async batchTrackEvents(events: EventData[]): Promise<void> {\r\n    try {\r\n      const jobs = events.map((eventData) => ({\r\n        name: \"process-event\",\r\n        data: {\r\n          ...eventData,\r\n          timestamp: new Date(),\r\n        },\r\n      }))\r\n\r\n      await this.dataCollectionQueue.addBulk(jobs)\r\n\r\n      // Process real-time events\r\n      await Promise.all(events.map((event) => this.realTimeAnalyticsService.processRealTimeEvent(event)))\r\n\r\n      this.logger.log(`Batch tracked ${events.length} events`)\r\n    } catch (error) {\r\n      this.logger.error(`Failed to batch track events: ${error.message}`, error.stack)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  async getEvents(filters: {\r\n    eventType?: EventType\r\n    userId?: string\r\n    sessionId?: string\r\n    startDate?: Date\r\n    endDate?: Date\r\n    limit?: number\r\n    offset?: number\r\n  }): Promise<{ events: AnalyticsEvent[]; total: number }> {\r\n    const query = this.analyticsEventRepository.createQueryBuilder(\"event\")\r\n\r\n    if (filters.eventType) {\r\n      query.andWhere(\"event.eventType = :eventType\", {\r\n        eventType: filters.eventType,\r\n      })\r\n    }\r\n\r\n    if (filters.userId) {\r\n      query.andWhere(\"event.userId = :userId\", { userId: filters.userId })\r\n    }\r\n\r\n    if (filters.sessionId) {\r\n      query.andWhere(\"event.sessionId = :sessionId\", {\r\n        sessionId: filters.sessionId,\r\n      })\r\n    }\r\n\r\n    if (filters.startDate) {\r\n      query.andWhere(\"event.timestamp >= :startDate\", {\r\n        startDate: filters.startDate,\r\n      })\r\n    }\r\n\r\n    if (filters.endDate) {\r\n      query.andWhere(\"event.timestamp <= :endDate\", {\r\n        endDate: filters.endDate,\r\n      })\r\n    }\r\n\r\n    query.orderBy(\"event.timestamp\", \"DESC\")\r\n\r\n    if (filters.limit) {\r\n      query.limit(filters.limit)\r\n    }\r\n\r\n    if (filters.offset) {\r\n      query.offset(filters.offset)\r\n    }\r\n\r\n    const [events, total] = await query.getManyAndCount()\r\n\r\n    return { events, total }\r\n  }\r\n}\r\n"],"version":3}