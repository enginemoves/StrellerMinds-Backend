{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\data-quality\\services\\data-quality-monitoring.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\data-quality\\services\\data-quality-monitoring.service.ts"],"sourcesContent":["import { Injectable, Logger } from \"@nestjs/common\"\r\nimport type { Repository } from \"typeorm\"\r\nimport { Cron, CronExpression } from \"@nestjs/schedule\"\r\nimport { EventEmitter2 } from \"@nestjs/event-emitter\"\r\nimport { InjectQueue } from \"@nestjs/bull\"\r\nimport type { Queue } from \"bull\"\r\n\r\nimport type { DataQualityMetric } from \"../entities/data-quality-metric.entity\"\r\nimport type { DataQualityIssue } from \"../entities/data-quality-issue.entity\"\r\n\r\nexport interface QualityDashboard {\r\n  overallScore: number\r\n  categoryScores: Record<string, number>\r\n  trendData: Array<{\r\n    date: string\r\n    score: number\r\n    category: string\r\n  }>\r\n  activeIssues: number\r\n  criticalIssues: number\r\n  recentIssues: DataQualityIssue[]\r\n  healthStatus: 'healthy' | 'warning' | 'critical'\r\n  lastUpdated: Date\r\n  entityCounts: Record<string, number>\r\n  performanceMetrics: {\r\n    avgProcessingTime: number\r\n    totalChecksToday: number\r\n    successRate: number\r\n  }\r\n}\r\n\r\nexport interface QualityAlert {\r\n  id: string\r\n  type: 'quality_issue' | 'threshold_breach' | 'system_alert'\r\n  severity: 'low' | 'medium' | 'high' | 'critical'\r\n  message: string\r\n  timestamp: Date\r\n  entityType: string\r\n  metadata?: Record<string, any>\r\n  acknowledged: boolean\r\n  resolvedAt?: Date\r\n}\r\n\r\nexport interface RealTimeMetrics {\r\n  currentScore: number\r\n  trend: 'improving' | 'declining' | 'stable'\r\n  activeChecks: number\r\n  failureRate: number\r\n  lastCheckTime: Date\r\n}\r\n\r\n@Injectable()\r\nexport class DataQualityMonitoringService {\r\n  private readonly logger = new Logger(DataQualityMonitoringService.name)\r\n\r\n  constructor(\r\n    private readonly metricRepository: Repository<DataQualityMetric>,\r\n    private readonly issueRepository: Repository<DataQualityIssue>,\r\n    private readonly eventEmitter: EventEmitter2,\r\n    @InjectQueue('data-quality-monitoring') private readonly monitoringQueue: Queue,\r\n  ) {}\r\n\r\n  async getDashboard(entityType?: string): Promise<QualityDashboard> {\r\n    const endDate = new Date()\r\n    const startDate = new Date()\r\n    startDate.setDate(startDate.getDate() - 30) // Last 30 days\r\n\r\n    // Get overall score\r\n    const overallScore = await this.calculateOverallScore(entityType, startDate, endDate)\r\n\r\n    // Get category scores\r\n    const categoryScores = await this.calculateCategoryScores(entityType, startDate, endDate)\r\n\r\n    // Get trend data\r\n    const trendData = await this.getTrendData(entityType, startDate, endDate)\r\n\r\n    // Get issue counts\r\n    const activeIssues = await this.issueRepository.count({\r\n      where: {\r\n        status: \"open\",\r\n        ...(entityType && { entityType }),\r\n      },\r\n    })\r\n\r\n    const criticalIssues = await this.issueRepository.count({\r\n      where: {\r\n        status: \"open\",\r\n        priority: \"critical\",\r\n        ...(entityType && { entityType }),\r\n      },\r\n    })\r\n\r\n    // Get recent issues\r\n    const recentIssues = await this.issueRepository.find({\r\n      where: {\r\n        ...(entityType && { entityType }),\r\n      },\r\n      order: { createdAt: \"DESC\" },\r\n      take: 10,\r\n    })\r\n\r\n    // Calculate health status\r\n    const healthStatus = this.calculateHealthStatus(overallScore, criticalIssues)\r\n    \r\n    // Get entity counts\r\n    const entityCounts = await this.getEntityCounts(entityType)\r\n    \r\n    // Get performance metrics\r\n    const performanceMetrics = await this.getPerformanceMetrics(entityType, startDate, endDate)\r\n\r\n    return {\r\n      overallScore,\r\n      categoryScores,\r\n      trendData,\r\n      activeIssues,\r\n      criticalIssues,\r\n      recentIssues,\r\n      healthStatus,\r\n      lastUpdated: new Date(),\r\n      entityCounts,\r\n      performanceMetrics,\r\n    }\r\n  }\r\n\r\n  private async calculateOverallScore(entityType?: string, startDate?: Date, endDate?: Date): Promise<number> {\r\n    const query = this.metricRepository.createQueryBuilder(\"metric\").select(\"AVG(metric.value)\", \"avgScore\")\r\n\r\n    if (entityType) {\r\n      query.andWhere(\"metric.entityType = :entityType\", { entityType })\r\n    }\r\n\r\n    if (startDate) {\r\n      query.andWhere(\"metric.timestamp >= :startDate\", { startDate })\r\n    }\r\n\r\n    if (endDate) {\r\n      query.andWhere(\"metric.timestamp <= :endDate\", { endDate })\r\n    }\r\n\r\n    const result = await query.getRawOne()\r\n    return Number.parseFloat(result.avgScore) || 0\r\n  }\r\n\r\n  private async calculateCategoryScores(\r\n    entityType?: string,\r\n    startDate?: Date,\r\n    endDate?: Date,\r\n  ): Promise<Record<string, number>> {\r\n    const query = this.metricRepository\r\n      .createQueryBuilder(\"metric\")\r\n      .select(\"metric.metricCategory\", \"category\")\r\n      .addSelect(\"AVG(metric.value)\", \"avgScore\")\r\n      .groupBy(\"metric.metricCategory\")\r\n\r\n    if (entityType) {\r\n      query.andWhere(\"metric.entityType = :entityType\", { entityType })\r\n    }\r\n\r\n    if (startDate) {\r\n      query.andWhere(\"metric.timestamp >= :startDate\", { startDate })\r\n    }\r\n\r\n    if (endDate) {\r\n      query.andWhere(\"metric.timestamp <= :endDate\", { endDate })\r\n    }\r\n\r\n    const results = await query.getRawMany()\r\n    const categoryScores: Record<string, number> = {}\r\n\r\n    for (const result of results) {\r\n      categoryScores[result.category] = Number.parseFloat(result.avgScore) || 0\r\n    }\r\n\r\n    return categoryScores\r\n  }\r\n\r\n  private async getTrendData(\r\n    entityType?: string,\r\n    startDate?: Date,\r\n    endDate?: Date,\r\n  ): Promise<\r\n    Array<{\r\n      date: string\r\n      score: number\r\n      category: string\r\n    }>\r\n  > {\r\n    const query = this.metricRepository\r\n      .createQueryBuilder(\"metric\")\r\n      .select(\"DATE(metric.timestamp)\", \"date\")\r\n      .addSelect(\"metric.metricCategory\", \"category\")\r\n      .addSelect(\"AVG(metric.value)\", \"score\")\r\n      .groupBy(\"DATE(metric.timestamp), metric.metricCategory\")\r\n      .orderBy(\"DATE(metric.timestamp)\", \"ASC\")\r\n\r\n    if (entityType) {\r\n      query.andWhere(\"metric.entityType = :entityType\", { entityType })\r\n    }\r\n\r\n    if (startDate) {\r\n      query.andWhere(\"metric.timestamp >= :startDate\", { startDate })\r\n    }\r\n\r\n    if (endDate) {\r\n      query.andWhere(\"metric.timestamp <= :endDate\", { endDate })\r\n    }\r\n\r\n    const results = await query.getRawMany()\r\n    return results.map((result) => ({\r\n      date: result.date,\r\n      score: Number.parseFloat(result.score) || 0,\r\n      category: result.category,\r\n    }))\r\n  }\r\n\r\n  async getMetricHistory(\r\n    metricName: string,\r\n    entityType?: string,\r\n    days = 30,\r\n  ): Promise<\r\n    Array<{\r\n      timestamp: Date\r\n      value: number\r\n      passed: boolean\r\n    }>\r\n  > {\r\n    const startDate = new Date()\r\n    startDate.setDate(startDate.getDate() - days)\r\n\r\n    const query = this.metricRepository\r\n      .createQueryBuilder(\"metric\")\r\n      .where(\"metric.metricName = :metricName\", { metricName })\r\n      .andWhere(\"metric.timestamp >= :startDate\", { startDate })\r\n\r\n    if (entityType) {\r\n      query.andWhere(\"metric.entityType = :entityType\", { entityType })\r\n    }\r\n\r\n    const metrics = await query.orderBy(\"metric.timestamp\", \"ASC\").getMany()\r\n\r\n    return metrics.map((metric) => ({\r\n      timestamp: metric.timestamp,\r\n      value: Number.parseFloat(metric.value.toString()),\r\n      passed: metric.passed,\r\n    }))\r\n  }\r\n\r\n  @Cron(CronExpression.EVERY_HOUR)\r\n  async monitorQualityThresholds(): Promise<void> {\r\n    this.logger.log(\"Starting quality threshold monitoring\")\r\n\r\n    try {\r\n      const recentMetrics = await this.metricRepository.find({\r\n        where: {\r\n          timestamp: new Date(Date.now() - 60 * 60 * 1000), // Last hour\r\n        },\r\n      })\r\n\r\n      for (const metric of recentMetrics) {\r\n        if (metric.threshold && metric.value < metric.threshold) {\r\n          this.logger.warn(\r\n            `Quality threshold breach: ${metric.metricName} = ${metric.value} (threshold: ${metric.threshold})`,\r\n          )\r\n          // Could trigger alerts here\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.error(`Quality monitoring failed: ${error.message}`, error.stack)\r\n    }\r\n  }\r\n\r\n  async getQualityAlerts(entityType?: string): Promise<\r\n    Array<{\r\n      id: string\r\n      type: string\r\n      severity: string\r\n      message: string\r\n      timestamp: Date\r\n      entityType: string\r\n    }>\r\n  > {\r\n    const alerts: Array<{\r\n      id: string\r\n      type: string\r\n      severity: string\r\n      message: string\r\n      timestamp: Date\r\n      entityType: string\r\n    }> = []\r\n\r\n    // Get critical issues as alerts\r\n    const criticalIssues = await this.issueRepository.find({\r\n      where: {\r\n        status: \"open\",\r\n        priority: \"critical\",\r\n        ...(entityType && { entityType }),\r\n      },\r\n      order: { createdAt: \"DESC\" },\r\n      take: 50,\r\n    })\r\n\r\n    for (const issue of criticalIssues) {\r\n      alerts.push({\r\n        id: issue.id,\r\n        type: \"quality_issue\",\r\n        severity: issue.priority,\r\n        message: issue.description,\r\n        timestamp: issue.createdAt,\r\n        entityType: issue.entityType,\r\n      })\r\n    }\r\n\r\n    // Get threshold breaches\r\n    const thresholdBreaches = await this.metricRepository.find({\r\n      where: {\r\n        passed: false,\r\n        ...(entityType && { entityType }),\r\n      },\r\n      order: { timestamp: \"DESC\" },\r\n      take: 50,\r\n    })\r\n\r\n    for (const breach of thresholdBreaches) {\r\n      alerts.push({\r\n        id: breach.id,\r\n        type: \"threshold_breach\",\r\n        severity: \"high\",\r\n        message: `${breach.metricName} failed threshold: ${breach.value} < ${breach.threshold}`,\r\n        timestamp: breach.timestamp,\r\n        entityType: breach.entityType,\r\n      })\r\n    }\r\n\r\n    return alerts.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\r\n  }\r\n\r\n  private calculateHealthStatus(overallScore: number, criticalIssues: number): 'healthy' | 'warning' | 'critical' {\r\n    if (criticalIssues > 0 || overallScore < 60) {\r\n      return 'critical'\r\n    }\r\n    if (overallScore < 80) {\r\n      return 'warning'\r\n    }\r\n    return 'healthy'\r\n  }\r\n\r\n  private async getEntityCounts(entityType?: string): Promise<Record<string, number>> {\r\n    const query = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('metric.entityType', 'entityType')\r\n      .addSelect('COUNT(*)', 'count')\r\n      .groupBy('metric.entityType')\r\n\r\n    if (entityType) {\r\n      query.where('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    const results = await query.getRawMany()\r\n    const counts: Record<string, number> = {}\r\n\r\n    for (const result of results) {\r\n      counts[result.entityType] = parseInt(result.count, 10)\r\n    }\r\n\r\n    return counts\r\n  }\r\n\r\n  private async getPerformanceMetrics(entityType?: string, startDate?: Date, endDate?: Date): Promise<{\r\n    avgProcessingTime: number\r\n    totalChecksToday: number\r\n    successRate: number\r\n  }> {\r\n    const today = new Date()\r\n    today.setHours(0, 0, 0, 0)\r\n\r\n    // Get total checks today\r\n    const totalChecksQuery = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .where('metric.timestamp >= :today', { today })\r\n\r\n    if (entityType) {\r\n      totalChecksQuery.andWhere('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    const totalChecksToday = await totalChecksQuery.getCount()\r\n\r\n    // Get success rate\r\n    const successQuery = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('AVG(CASE WHEN metric.passed = true THEN 1 ELSE 0 END)', 'successRate')\r\n\r\n    if (entityType) {\r\n      successQuery.andWhere('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    if (startDate) {\r\n      successQuery.andWhere('metric.timestamp >= :startDate', { startDate })\r\n    }\r\n\r\n    if (endDate) {\r\n      successQuery.andWhere('metric.timestamp <= :endDate', { endDate })\r\n    }\r\n\r\n    const successResult = await successQuery.getRawOne()\r\n    const successRate = parseFloat(successResult.successRate) * 100 || 0\r\n\r\n    return {\r\n      avgProcessingTime: 0, // This would need to be tracked separately\r\n      totalChecksToday,\r\n      successRate,\r\n    }\r\n  }\r\n\r\n  async getRealTimeMetrics(entityType?: string): Promise<RealTimeMetrics> {\r\n    const now = new Date()\r\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)\r\n\r\n    // Get current score (last hour average)\r\n    const currentScoreQuery = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('AVG(metric.value)', 'avgScore')\r\n      .where('metric.timestamp >= :oneHourAgo', { oneHourAgo })\r\n\r\n    if (entityType) {\r\n      currentScoreQuery.andWhere('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    const currentScoreResult = await currentScoreQuery.getRawOne()\r\n    const currentScore = parseFloat(currentScoreResult.avgScore) || 0\r\n\r\n    // Get trend (compare with previous hour)\r\n    const twoHoursAgo = new Date(now.getTime() - 2 * 60 * 60 * 1000)\r\n    const previousScoreQuery = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('AVG(metric.value)', 'avgScore')\r\n      .where('metric.timestamp >= :twoHoursAgo', { twoHoursAgo })\r\n      .andWhere('metric.timestamp < :oneHourAgo', { oneHourAgo })\r\n\r\n    if (entityType) {\r\n      previousScoreQuery.andWhere('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    const previousScoreResult = await previousScoreQuery.getRawOne()\r\n    const previousScore = parseFloat(previousScoreResult.avgScore) || 0\r\n\r\n    let trend: 'improving' | 'declining' | 'stable' = 'stable'\r\n    const scoreDiff = currentScore - previousScore\r\n    if (Math.abs(scoreDiff) > 5) {\r\n      trend = scoreDiff > 0 ? 'improving' : 'declining'\r\n    }\r\n\r\n    // Get active checks count\r\n    const activeChecks = await this.metricRepository.count({\r\n      where: {\r\n        timestamp: new Date(now.getTime() - 5 * 60 * 1000), // Last 5 minutes\r\n        ...(entityType && { entityType }),\r\n      },\r\n    })\r\n\r\n    // Get failure rate\r\n    const failureQuery = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('AVG(CASE WHEN metric.passed = false THEN 1 ELSE 0 END)', 'failureRate')\r\n      .where('metric.timestamp >= :oneHourAgo', { oneHourAgo })\r\n\r\n    if (entityType) {\r\n      failureQuery.andWhere('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    const failureResult = await failureQuery.getRawOne()\r\n    const failureRate = parseFloat(failureResult.failureRate) * 100 || 0\r\n\r\n    // Get last check time\r\n    const lastCheckQuery = this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('MAX(metric.timestamp)', 'lastCheck')\r\n\r\n    if (entityType) {\r\n      lastCheckQuery.andWhere('metric.entityType = :entityType', { entityType })\r\n    }\r\n\r\n    const lastCheckResult = await lastCheckQuery.getRawOne()\r\n    const lastCheckTime = lastCheckResult.lastCheck || now\r\n\r\n    return {\r\n      currentScore,\r\n      trend,\r\n      activeChecks,\r\n      failureRate,\r\n      lastCheckTime,\r\n    }\r\n  }\r\n\r\n  async acknowledgeAlert(alertId: string, acknowledgedBy: string): Promise<void> {\r\n    // This would update an alert acknowledgment table if we had one\r\n    // For now, we'll emit an event\r\n    this.eventEmitter.emit('alert.acknowledged', {\r\n      alertId,\r\n      acknowledgedBy,\r\n      timestamp: new Date(),\r\n    })\r\n  }\r\n\r\n  async scheduleQualityCheck(entityType: string, delay = 0): Promise<void> {\r\n    await this.monitoringQueue.add(\r\n      'quality-check',\r\n      { entityType },\r\n      { delay }\r\n    )\r\n  }\r\n\r\n  @Cron(CronExpression.EVERY_5_MINUTES)\r\n  async performRealTimeMonitoring(): Promise<void> {\r\n    try {\r\n      const entityTypes = await this.getUniqueEntityTypes()\r\n      \r\n      for (const entityType of entityTypes) {\r\n        const metrics = await this.getRealTimeMetrics(entityType)\r\n        \r\n        // Emit real-time metrics event\r\n        this.eventEmitter.emit('metrics.realtime', {\r\n          entityType,\r\n          metrics,\r\n          timestamp: new Date(),\r\n        })\r\n\r\n        // Check for critical conditions\r\n        if (metrics.failureRate > 50) {\r\n          this.eventEmitter.emit('alert.critical', {\r\n            type: 'high_failure_rate',\r\n            entityType,\r\n            failureRate: metrics.failureRate,\r\n            timestamp: new Date(),\r\n          })\r\n        }\r\n\r\n        if (metrics.currentScore < 60) {\r\n          this.eventEmitter.emit('alert.critical', {\r\n            type: 'low_quality_score',\r\n            entityType,\r\n            score: metrics.currentScore,\r\n            timestamp: new Date(),\r\n          })\r\n        }\r\n      }\r\n    } catch (error: any) {\r\n      this.logger.error(`Real-time monitoring failed: ${error.message}`, error.stack)\r\n    }\r\n  }\r\n\r\n  private async getUniqueEntityTypes(): Promise<string[]> {\r\n    const result = await this.metricRepository\r\n      .createQueryBuilder('metric')\r\n      .select('DISTINCT metric.entityType', 'entityType')\r\n      .getRawMany()\r\n\r\n    return result.map((r: any) => r.entityType)\r\n  }\r\n}\r\n"],"version":3}