{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\auth\\jwt.strategy.ts","mappings":";;;;;;;;;;;;;AAAA,2CAAmE;AACnE,+CAAoD;AACpD,+CAAoD;AACpD,2CAA+C;AAC/C,oEAAgE;AAIzD,IAAM,WAAW,GAAjB,MAAM,WAAY,SAAQ,IAAA,2BAAgB,EAAC,uBAAQ,CAAC;IACzD,YACmB,YAA0B,EAC1B,aAA4B;QAE7C,KAAK,CAAC;YACJ,cAAc,EAAE,yBAAU,CAAC,2BAA2B,EAAE;YACxD,gBAAgB,EAAE,KAAK;YACvB,mBAAmB,EAAE,CAAC,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,EAAE;gBAClD,MAAM,aAAa,GAAG,aAAa,CAAC,GAAG,CAAS,YAAY,CAAC,CAAC;gBAC9D,MAAM,OAAO,GAAG,CAAC,aAAa,CAAC,GAAG,CAAS,aAAa,CAAC,IAAI,EAAE,CAAC;qBAC7D,KAAK,CAAC,GAAG,CAAC;qBACV,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;qBACpB,MAAM,CAAC,OAAO,CAAC,CAAC;gBACnB,KAAK,MAAM,MAAM,IAAI,CAAC,aAAa,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;oBACjD,IAAI,CAAC;wBACH,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;wBACnB,OAAO;oBACT,CAAC;oBAAC,MAAM,CAAC,CAAA,CAAC;gBACZ,CAAC;gBACD,IAAI,CAAC,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC;YACxC,CAAC;SACF,CAAC,CAAC;QApBc,iBAAY,GAAZ,YAAY,CAAc;QAC1B,kBAAa,GAAb,aAAa,CAAe;IAoB/C,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,OAId;QACC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC1D,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,IAAI,8BAAqB,CAAC,uBAAuB,CAAC,CAAC;QAC3D,CAAC;QAED,OAAO;YACL,EAAE,EAAE,OAAO,CAAC,GAAG;YACf,KAAK,EAAE,OAAO,CAAC,KAAK;YACpB,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC;IACJ,CAAC;CACF,CAAA;AAzCY,kCAAW;sBAAX,WAAW;IADvB,IAAA,mBAAU,GAAE;yDAGsB,4BAAY,oBAAZ,4BAAY,oDACX,sBAAa,oBAAb,sBAAa;GAHpC,WAAW,CAyCvB","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\auth\\jwt.strategy.ts"],"sourcesContent":["import { Injectable, UnauthorizedException } from '@nestjs/common';\r\nimport { PassportStrategy } from '@nestjs/passport';\r\nimport { ExtractJwt, Strategy } from 'passport-jwt';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport { UsersService } from 'src/users/services/users.service';\r\nimport { User } from '../users/entities/user.entity';\r\n\r\n@Injectable()\r\nexport class JwtStrategy extends PassportStrategy(Strategy) {\r\n  constructor(\r\n    private readonly usersService: UsersService,\r\n    private readonly configService: ConfigService,\r\n  ) {\r\n    super({\r\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\r\n      ignoreExpiration: false,\r\n      secretOrKeyProvider: (request, rawJwtToken, done) => {\r\n        const currentSecret = configService.get<string>('JWT_SECRET');\r\n        const secrets = (configService.get<string>('JWT_SECRETS') || '')\r\n          .split(',')\r\n          .map((s) => s.trim())\r\n          .filter(Boolean);\r\n        for (const secret of [currentSecret, ...secrets]) {\r\n          try {\r\n            done(null, secret);\r\n            return;\r\n          } catch {}\r\n        }\r\n        done(new Error('Invalid JWT secret'));\r\n      },\r\n    });\r\n  }\r\n\r\n  async validate(payload: {\r\n    sub: string;\r\n    email: string;\r\n    roles: string[];\r\n  }): Promise<any> {\r\n    const user = await this.usersService.findOne(payload.sub);\r\n    if (!user) {\r\n      throw new UnauthorizedException('User no longer exists');\r\n    }\r\n\r\n    return {\r\n      id: payload.sub,\r\n      email: payload.email,\r\n      roles: payload.roles,\r\n    };\r\n  }\r\n}\r\n"],"version":3}