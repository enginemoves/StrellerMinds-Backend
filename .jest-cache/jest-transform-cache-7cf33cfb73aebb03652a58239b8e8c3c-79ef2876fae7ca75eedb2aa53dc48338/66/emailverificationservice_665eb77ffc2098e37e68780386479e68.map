{"file":"C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\email-verification\\email-verification.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\ojoseph\\Documents\\StrellerMinds-Backend\\src\\email-verification\\email-verification.service.ts"],"sourcesContent":["import { Injectable, BadRequestException, NotFoundException, Logger } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository } from 'typeorm';\r\nimport { EmailService } from '../email/email.service';\r\nimport * as crypto from 'crypto';\r\nimport { User } from './entities/user.entity';\r\n\r\n/**\r\n * EmailVerificationService provides logic for sending, verifying, and resending email verification.\r\n */\r\n@Injectable()\r\nexport class EmailVerificationService {\r\n  private readonly logger = new Logger(EmailVerificationService.name);\r\n  private readonly TOKEN_EXPIRY_HOURS = 24;\r\n\r\n  constructor(\r\n    @InjectRepository(User)\r\n    private userRepository: Repository<User>,\r\n    private emailService: EmailService,\r\n  ) {}\r\n\r\n  /**\r\n   * Generate a secure verification token.\r\n   * @returns A random token string\r\n   */\r\n  private generateVerificationToken(): string {\r\n    return crypto.randomBytes(32).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Calculate token expiry date.\r\n   * @returns Date object for token expiry\r\n   */\r\n  private getTokenExpiry(): Date {\r\n    const expiry = new Date();\r\n    expiry.setHours(expiry.getHours() + this.TOKEN_EXPIRY_HOURS);\r\n    return expiry;\r\n  }\r\n\r\n  /**\r\n   * Send verification email to user.\r\n   * @param email - User email address\r\n   * @returns Success message\r\n   */\r\n  async sendVerificationEmail(email: string): Promise<{ message: string }> {\r\n    try {\r\n      const user = await this.userRepository.findOne({ where: { email } });\r\n      \r\n      if (!user) {\r\n        throw new NotFoundException('User not found');\r\n      }\r\n\r\n      if (user.isEmailVerified) {\r\n        throw new BadRequestException('Email is already verified');\r\n      }\r\n\r\n      // Generate new token and expiry\r\n      const verificationToken = this.generateVerificationToken();\r\n      const tokenExpiry = this.getTokenExpiry();\r\n\r\n      // Update user with new token\r\n      await this.userRepository.update(user.id, {\r\n        emailVerificationToken: verificationToken,\r\n        emailVerificationTokenExpiry: tokenExpiry,\r\n      });\r\n\r\n      // Send verification email\r\n      await this.emailService.sendVerificationEmail(\r\n        email,\r\n        verificationToken,\r\n        user.id\r\n      );\r\n\r\n      this.logger.log(`Verification email sent to ${email}`);\r\n\r\n      return {\r\n        message: 'Verification email sent successfully',\r\n      };\r\n    } catch (error) {\r\n      this.logger.error(`Failed to send verification email to ${email}`, error.stack);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify email using a verification token.\r\n   * @param token - Verification token\r\n   * @returns Success message\r\n   */\r\n  async verifyEmail(token: string): Promise<{ message: string; user: Partial<User> }> {\r\n    try {\r\n      const user = await this.userRepository.findOne({\r\n        where: { emailVerificationToken: token },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new BadRequestException('Invalid or expired verification token');\r\n      }\r\n\r\n      if (user.isEmailVerified) {\r\n        throw new BadRequestException('Email is already verified');\r\n      }\r\n\r\n      // Check if token is expired\r\n      if (new Date() > user.emailVerificationTokenExpiry) {\r\n        throw new BadRequestException('Verification token has expired');\r\n      }\r\n\r\n      // Verify the email\r\n      await this.userRepository.update(user.id, {\r\n        isEmailVerified: true,\r\n        emailVerificationToken: null,\r\n        emailVerificationTokenExpiry: null,\r\n      });\r\n\r\n      this.logger.log(`Email verified for user ${user.email}`);\r\n\r\n      return {\r\n        message: 'Email verified successfully',\r\n        user: {\r\n          id: user.id,\r\n          email: user.email,\r\n          isEmailVerified: true,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      this.logger.error(`Failed to verify email with token ${token}`, error.stack);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resend verification email to user.\r\n   * @param email - User email address\r\n   * @returns Success message\r\n   */\r\n  async resendVerificationEmail(email: string): Promise<{ message: string }> {\r\n    try {\r\n      const user = await this.userRepository.findOne({ where: { email } });\r\n\r\n      if (!user) {\r\n        throw new NotFoundException('User not found');\r\n      }\r\n\r\n      if (user.isEmailVerified) {\r\n        throw new BadRequestException('Email is already verified');\r\n      }\r\n\r\n      // Check if we can resend (rate limiting)\r\n      if (user.emailVerificationTokenExpiry && \r\n          new Date() < new Date(user.emailVerificationTokenExpiry.getTime() - (23 * 60 * 60 * 1000))) {\r\n        throw new BadRequestException('Please wait before requesting another verification email');\r\n      }\r\n\r\n      return await this.sendVerificationEmail(email);\r\n    } catch (error) {\r\n      this.logger.error(`Failed to resend verification email to ${email}`, error.stack);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if user email is verified\r\n   */\r\n  async isEmailVerified(userId: string): Promise<boolean> {\r\n    const user = await this.userRepository.findOne({ \r\n      where: { id: userId },\r\n      select: ['isEmailVerified']\r\n    });\r\n    \r\n    return user?.isEmailVerified || false;\r\n  }\r\n\r\n  /**\r\n   * Clean up expired tokens (can be called by a cron job)\r\n   */\r\n  async cleanupExpiredTokens(): Promise<void> {\r\n    try {\r\n      const result = await this.userRepository.update(\r\n        {\r\n          emailVerificationTokenExpiry: new Date(),\r\n          isEmailVerified: false,\r\n        },\r\n        {\r\n          emailVerificationToken: null,\r\n          emailVerificationTokenExpiry: null,\r\n        }\r\n      );\r\n\r\n      this.logger.log(`Cleaned up ${result.affected} expired verification tokens`);\r\n    } catch (error) {\r\n      this.logger.error('Failed to cleanup expired tokens', error.stack);\r\n    }\r\n  }\r\n}\r\n"],"version":3}