ca8021d6b01e6404d10a93269f589e67
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var EmailVerificationService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmailVerificationService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const email_service_1 = require("../email/email.service");
const crypto = __importStar(require("crypto"));
const user_entity_1 = require("./entities/user.entity");
/**
 * EmailVerificationService provides logic for sending, verifying, and resending email verification.
 */
let EmailVerificationService = EmailVerificationService_1 = class EmailVerificationService {
    constructor(userRepository, emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
        this.logger = new common_1.Logger(EmailVerificationService_1.name);
        this.TOKEN_EXPIRY_HOURS = 24;
    }
    /**
     * Generate a secure verification token.
     * @returns A random token string
     */
    generateVerificationToken() {
        return crypto.randomBytes(32).toString('hex');
    }
    /**
     * Calculate token expiry date.
     * @returns Date object for token expiry
     */
    getTokenExpiry() {
        const expiry = new Date();
        expiry.setHours(expiry.getHours() + this.TOKEN_EXPIRY_HOURS);
        return expiry;
    }
    /**
     * Send verification email to user.
     * @param email - User email address
     * @returns Success message
     */
    async sendVerificationEmail(email) {
        try {
            const user = await this.userRepository.findOne({ where: { email } });
            if (!user) {
                throw new common_1.NotFoundException('User not found');
            }
            if (user.isEmailVerified) {
                throw new common_1.BadRequestException('Email is already verified');
            }
            // Generate new token and expiry
            const verificationToken = this.generateVerificationToken();
            const tokenExpiry = this.getTokenExpiry();
            // Update user with new token
            await this.userRepository.update(user.id, {
                emailVerificationToken: verificationToken,
                emailVerificationTokenExpiry: tokenExpiry,
            });
            // Send verification email
            await this.emailService.sendVerificationEmail(email, verificationToken, user.id);
            this.logger.log(`Verification email sent to ${email}`);
            return {
                message: 'Verification email sent successfully',
            };
        }
        catch (error) {
            this.logger.error(`Failed to send verification email to ${email}`, error.stack);
            throw error;
        }
    }
    /**
     * Verify email using a verification token.
     * @param token - Verification token
     * @returns Success message
     */
    async verifyEmail(token) {
        try {
            const user = await this.userRepository.findOne({
                where: { emailVerificationToken: token },
            });
            if (!user) {
                throw new common_1.BadRequestException('Invalid or expired verification token');
            }
            if (user.isEmailVerified) {
                throw new common_1.BadRequestException('Email is already verified');
            }
            // Check if token is expired
            if (new Date() > user.emailVerificationTokenExpiry) {
                throw new common_1.BadRequestException('Verification token has expired');
            }
            // Verify the email
            await this.userRepository.update(user.id, {
                isEmailVerified: true,
                emailVerificationToken: null,
                emailVerificationTokenExpiry: null,
            });
            this.logger.log(`Email verified for user ${user.email}`);
            return {
                message: 'Email verified successfully',
                user: {
                    id: user.id,
                    email: user.email,
                    isEmailVerified: true,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to verify email with token ${token}`, error.stack);
            throw error;
        }
    }
    /**
     * Resend verification email to user.
     * @param email - User email address
     * @returns Success message
     */
    async resendVerificationEmail(email) {
        try {
            const user = await this.userRepository.findOne({ where: { email } });
            if (!user) {
                throw new common_1.NotFoundException('User not found');
            }
            if (user.isEmailVerified) {
                throw new common_1.BadRequestException('Email is already verified');
            }
            // Check if we can resend (rate limiting)
            if (user.emailVerificationTokenExpiry &&
                new Date() < new Date(user.emailVerificationTokenExpiry.getTime() - (23 * 60 * 60 * 1000))) {
                throw new common_1.BadRequestException('Please wait before requesting another verification email');
            }
            return await this.sendVerificationEmail(email);
        }
        catch (error) {
            this.logger.error(`Failed to resend verification email to ${email}`, error.stack);
            throw error;
        }
    }
    /**
     * Check if user email is verified
     */
    async isEmailVerified(userId) {
        const user = await this.userRepository.findOne({
            where: { id: userId },
            select: ['isEmailVerified']
        });
        return user?.isEmailVerified || false;
    }
    /**
     * Clean up expired tokens (can be called by a cron job)
     */
    async cleanupExpiredTokens() {
        try {
            const result = await this.userRepository.update({
                emailVerificationTokenExpiry: new Date(),
                isEmailVerified: false,
            }, {
                emailVerificationToken: null,
                emailVerificationTokenExpiry: null,
            });
            this.logger.log(`Cleaned up ${result.affected} expired verification tokens`);
        }
        catch (error) {
            this.logger.error('Failed to cleanup expired tokens', error.stack);
        }
    }
};
exports.EmailVerificationService = EmailVerificationService;
exports.EmailVerificationService = EmailVerificationService = EmailVerificationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof email_service_1.EmailService !== "undefined" && email_service_1.EmailService) === "function" ? _b : Object])
], EmailVerificationService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxvam9zZXBoXFxEb2N1bWVudHNcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFxlbWFpbC12ZXJpZmljYXRpb25cXGVtYWlsLXZlcmlmaWNhdGlvbi5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTRGO0FBQzVGLDZDQUFtRDtBQUNuRCxxQ0FBcUM7QUFDckMsMERBQXNEO0FBQ3RELCtDQUFpQztBQUNqQyx3REFBOEM7QUFFOUM7O0dBRUc7QUFFSSxJQUFNLHdCQUF3QixnQ0FBOUIsTUFBTSx3QkFBd0I7SUFJbkMsWUFFRSxjQUF3QyxFQUNoQyxZQUEwQjtRQUQxQixtQkFBYyxHQUFkLGNBQWMsQ0FBa0I7UUFDaEMsaUJBQVksR0FBWixZQUFZLENBQWM7UUFObkIsV0FBTSxHQUFHLElBQUksZUFBTSxDQUFDLDBCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25ELHVCQUFrQixHQUFHLEVBQUUsQ0FBQztJQU10QyxDQUFDO0lBRUo7OztPQUdHO0lBQ0sseUJBQXlCO1FBQy9CLE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGNBQWM7UUFDcEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUMxQixNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUM3RCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxLQUFhO1FBQ3ZDLElBQUksQ0FBQztZQUNILE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFB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SSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUM7WUFDN0MsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRTtZQUNyQixNQUFNLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztTQUM1QixDQUFDLENBQUM7UUFFSCxPQUFPLElBQUksRUFBRSxlQUFlLElBQUksS0FBSyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxvQkFBb0I7UUFDeEIsSUFBSSxDQUFDO1lBQ0gsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FDN0M7Z0JBQ0UsNEJBQTRCLEVBQUUsSUFBSSxJQUFJLEVBQUU7Z0JBQ3hDLGVBQWUsRUFBRSxLQUFLO2FBQ3ZCLEVBQ0Q7Z0JBQ0Usc0JBQXNCLEVBQUUsSUFBSTtnQkFDNUIsNEJBQTRCLEVBQUUsSUFBSTthQUNuQyxDQUNGLENBQUM7WUFFRixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFjLE1BQU0sQ0FBQyxRQUFRLDhCQUE4QixDQUFDLENBQUM7UUFDL0UsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckUsQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBdkxZLDREQUF3QjttQ0FBeEIsd0JBQXdCO0lBRHBDLElBQUEsbUJBQVUsR0FBRTtJQU1SLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyxrQkFBSSxDQUFDLENBQUE7eURBQ0Msb0JBQVUsb0JBQVYsb0JBQVUsb0RBQ1osNEJBQVksb0JBQVosNEJBQVk7R0FQekIsd0JBQXdCLENBdUxwQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXG9qb3NlcGhcXERvY3VtZW50c1xcU3RyZWxsZXJNaW5kcy1CYWNrZW5kXFxzcmNcXGVtYWlsLXZlcmlmaWNhdGlvblxcZW1haWwtdmVyaWZpY2F0aW9uLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgQmFkUmVxdWVzdEV4Y2VwdGlvbiwgTm90Rm91bmRFeGNlcHRpb24sIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcclxuaW1wb3J0IHsgSW5qZWN0UmVwb3NpdG9yeSB9IGZyb20gJ0BuZXN0anMvdHlwZW9ybSc7XHJcbmltcG9ydCB7IFJlcG9zaXRvcnkgfSBmcm9tICd0eXBlb3JtJztcclxuaW1wb3J0IHsgRW1haWxTZXJ2aWNlIH0gZnJvbSAnLi4vZW1haWwvZW1haWwuc2VydmljZSc7XHJcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi9lbnRpdGllcy91c2VyLmVudGl0eSc7XHJcblxyXG4vKipcclxuICogRW1haWxWZXJpZmljYXRpb25TZXJ2aWNlIHByb3ZpZGVzIGxvZ2ljIGZvciBzZW5kaW5nLCB2ZXJpZnlpbmcsIGFuZCByZXNlbmRpbmcgZW1haWwgdmVyaWZpY2F0aW9uLlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRW1haWxWZXJpZmljYXRpb25TZXJ2aWNlIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoRW1haWxWZXJpZmljYXRpb25TZXJ2aWNlLm5hbWUpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgVE9LRU5fRVhQSVJZX0hPVVJTID0gMjQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdFJlcG9zaXRvcnkoVXNlcilcclxuICAgIHByaXZhdGUgdXNlclJlcG9zaXRvcnk6IFJlcG9zaXRvcnk8VXNlcj4sXHJcbiAgICBwcml2YXRlIGVtYWlsU2VydmljZTogRW1haWxTZXJ2aWNlLFxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBzZWN1cmUgdmVyaWZpY2F0aW9uIHRva2VuLlxyXG4gICAqIEByZXR1cm5zIEEgcmFuZG9tIHRva2VuIHN0cmluZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2VuZXJhdGVWZXJpZmljYXRpb25Ub2tlbigpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcygzMikudG9TdHJpbmcoJ2hleCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRva2VuIGV4cGlyeSBkYXRlLlxyXG4gICAqIEByZXR1cm5zIERhdGUgb2JqZWN0IGZvciB0b2tlbiBleHBpcnlcclxuICAgKi9cclxuICBwcml2YXRlIGdldFRva2VuRXhwaXJ5KCk6IERhdGUge1xyXG4gICAgY29uc3QgZXhwaXJ5ID0gbmV3IERhdGUoKTtcclxuICAgIGV4cGlyeS5zZXRIb3VycyhleHBpcnkuZ2V0SG91cnMoKSArIHRoaXMuVE9LRU5fRVhQSVJZX0hPVVJTKTtcclxuICAgIHJldHVybiBleHBpcnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIHZlcmlmaWNhdGlvbiBlbWFpbCB0byB1c2VyLlxyXG4gICAqIEBwYXJhbSBlbWFpbCAtIFVzZXIgZW1haWwgYWRkcmVzc1xyXG4gICAqIEByZXR1cm5zIFN1Y2Nlc3MgbWVzc2FnZVxyXG4gICAqL1xyXG4gIGFzeW5jIHNlbmRWZXJpZmljYXRpb25FbWFpbChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5maW5kT25lKHsgd2hlcmU6IHsgZW1haWwgfSB9KTtcclxuICAgICAgXHJcbiAgICAgIGlmICghdXNlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignVXNlciBub3QgZm91bmQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHVzZXIuaXNFbWFpbFZlcmlmaWVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oJ0VtYWlsIGlzIGFscmVhZHkgdmVyaWZpZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2VuZXJhdGUgbmV3IHRva2VuIGFuZCBleHBpcnlcclxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uVG9rZW4gPSB0aGlzLmdlbmVyYXRlVmVyaWZpY2F0aW9uVG9rZW4oKTtcclxuICAgICAgY29uc3QgdG9rZW5FeHBpcnkgPSB0aGlzLmdldFRva2VuRXhwaXJ5KCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdXNlciB3aXRoIG5ldyB0b2tlblxyXG4gICAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnVwZGF0ZSh1c2VyLmlkLCB7XHJcbiAgICAgICAgZW1haWxWZXJpZmljYXRpb25Ub2tlbjogdmVyaWZpY2F0aW9uVG9rZW4sXHJcbiAgICAgICAgZW1haWxWZXJpZmljYXRpb25Ub2tlbkV4cGlyeTogdG9rZW5FeHBpcnksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU2VuZCB2ZXJpZmljYXRpb24gZW1haWxcclxuICAgICAgYXdhaXQgdGhpcy5lbWFpbFNlcnZpY2Uuc2VuZFZlcmlmaWNhdGlvbkVtYWlsKFxyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIHZlcmlmaWNhdGlvblRva2VuLFxyXG4gICAgICAgIHVzZXIuaWRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgVmVyaWZpY2F0aW9uIGVtYWlsIHNlbnQgdG8gJHtlbWFpbH1gKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVzc2FnZTogJ1ZlcmlmaWNhdGlvbiBlbWFpbCBzZW50IHN1Y2Nlc3NmdWxseScsXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHNlbmQgdmVyaWZpY2F0aW9uIGVtYWlsIHRvICR7ZW1haWx9YCwgZXJyb3Iuc3RhY2spO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZlcmlmeSBlbWFpbCB1c2luZyBhIHZlcmlmaWNhdGlvbiB0b2tlbi5cclxuICAgKiBAcGFyYW0gdG9rZW4gLSBWZXJpZmljYXRpb24gdG9rZW5cclxuICAgKiBAcmV0dXJucyBTdWNjZXNzIG1lc3NhZ2VcclxuICAgKi9cclxuICBhc3luYyB2ZXJpZnlFbWFpbCh0b2tlbjogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZzsgdXNlcjogUGFydGlhbDxVc2VyPiB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5maW5kT25lKHtcclxuICAgICAgICB3aGVyZTogeyBlbWFpbFZlcmlmaWNhdGlvblRva2VuOiB0b2tlbiB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghdXNlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKCdJbnZhbGlkIG9yIGV4cGlyZWQgdmVyaWZpY2F0aW9uIHRva2VuJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh1c2VyLmlzRW1haWxWZXJpZmllZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKCdFbWFpbCBpcyBhbHJlYWR5IHZlcmlmaWVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRva2VuIGlzIGV4cGlyZWRcclxuICAgICAgaWYgKG5ldyBEYXRlKCkgPiB1c2VyLmVtYWlsVmVyaWZpY2F0aW9uVG9rZW5FeHBpcnkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbignVmVyaWZpY2F0aW9uIHRva2VuIGhhcyBleHBpcmVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZlcmlmeSB0aGUgZW1haWxcclxuICAgICAgYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS51cGRhdGUodXNlci5pZCwge1xyXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogdHJ1ZSxcclxuICAgICAgICBlbWFpbFZlcmlmaWNhdGlvblRva2VuOiBudWxsLFxyXG4gICAgICAgIGVtYWlsVmVyaWZpY2F0aW9uVG9rZW5FeHBpcnk6IG51bGwsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5sb2dnZXIubG9nKGBFbWFpbCB2ZXJpZmllZCBmb3IgdXNlciAke3VzZXIuZW1haWx9YCk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG1lc3NhZ2U6ICdFbWFpbCB2ZXJpZmllZCBzdWNjZXNzZnVsbHknLFxyXG4gICAgICAgIHVzZXI6IHtcclxuICAgICAgICAgIGlkOiB1c2VyLmlkLFxyXG4gICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXHJcbiAgICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gdmVyaWZ5IGVtYWlsIHdpdGggdG9rZW4gJHt0b2tlbn1gLCBlcnJvci5zdGFjayk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZW5kIHZlcmlmaWNhdGlvbiBlbWFpbCB0byB1c2VyLlxyXG4gICAqIEBwYXJhbSBlbWFpbCAtIFVzZXIgZW1haWwgYWRkcmVzc1xyXG4gICAqIEByZXR1cm5zIFN1Y2Nlc3MgbWVzc2FnZVxyXG4gICAqL1xyXG4gIGFzeW5jIHJlc2VuZFZlcmlmaWNhdGlvbkVtYWlsKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRPbmUoeyB3aGVyZTogeyBlbWFpbCB9IH0pO1xyXG5cclxuICAgICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdVc2VyIG5vdCBmb3VuZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodXNlci5pc0VtYWlsVmVyaWZpZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbignRW1haWwgaXMgYWxyZWFkeSB2ZXJpZmllZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gcmVzZW5kIChyYXRlIGxpbWl0aW5nKVxyXG4gICAgICBpZiAodXNlci5lbWFpbFZlcmlmaWNhdGlvblRva2VuRXhwaXJ5ICYmIFxyXG4gICAgICAgICAgbmV3IERhdGUoKSA8IG5ldyBEYXRlKHVzZXIuZW1haWxWZXJpZmljYXRpb25Ub2tlbkV4cGlyeS5nZXRUaW1lKCkgLSAoMjMgKiA2MCAqIDYwICogMTAwMCkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oJ1BsZWFzZSB3YWl0IGJlZm9yZSByZXF1ZXN0aW5nIGFub3RoZXIgdmVyaWZpY2F0aW9uIGVtYWlsJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRWZXJpZmljYXRpb25FbWFpbChlbWFpbCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHJlc2VuZCB2ZXJpZmljYXRpb24gZW1haWwgdG8gJHtlbWFpbH1gLCBlcnJvci5zdGFjayk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdXNlciBlbWFpbCBpcyB2ZXJpZmllZFxyXG4gICAqL1xyXG4gIGFzeW5jIGlzRW1haWxWZXJpZmllZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkuZmluZE9uZSh7IFxyXG4gICAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXHJcbiAgICAgIHNlbGVjdDogWydpc0VtYWlsVmVyaWZpZWQnXVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB1c2VyPy5pc0VtYWlsVmVyaWZpZWQgfHwgZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCBleHBpcmVkIHRva2VucyAoY2FuIGJlIGNhbGxlZCBieSBhIGNyb24gam9iKVxyXG4gICAqL1xyXG4gIGFzeW5jIGNsZWFudXBFeHBpcmVkVG9rZW5zKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS51cGRhdGUoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZW1haWxWZXJpZmljYXRpb25Ub2tlbkV4cGlyeTogbmV3IERhdGUoKSxcclxuICAgICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBlbWFpbFZlcmlmaWNhdGlvblRva2VuOiBudWxsLFxyXG4gICAgICAgICAgZW1haWxWZXJpZmljYXRpb25Ub2tlbkV4cGlyeTogbnVsbCxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5sb2coYENsZWFuZWQgdXAgJHtyZXN1bHQuYWZmZWN0ZWR9IGV4cGlyZWQgdmVyaWZpY2F0aW9uIHRva2Vuc2ApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhbnVwIGV4cGlyZWQgdG9rZW5zJywgZXJyb3Iuc3RhY2spO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=